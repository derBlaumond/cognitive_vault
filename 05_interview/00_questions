# 📚 기술 면접 준비 노트 (Junior Developer)

## 📝 면접에 대한 고찰

면접을 많이 다녀보다보니 기술면접에서 회사의 이미지나 같이 일하게 될 개발 팀원들의 수준, 그리고 이 회사에서 성장할 수 있는 성장성을 가늠할 수 있겠다는 생각이 들게 된 부분이 기술면접이였던 것 같습니다. 코딩테스트를 보는 건 본인의 실력을 뽐낼 순 있지만, 같이 일하게 될 시니어 개발자나 개발팀들의 실력은 면접을 통해 알 수가 없습니다. 주니어 개발자로 들어왔지만 자신의 분야를 깊이 배울 수 없는 회사면 굳이 오래다닐 이유가 없다는 거죠. 그래서 면접을 볼때 참여하는 개발자의 질문 수준에서 그 회사의 수준 깊이가 보인다는 걸 직감할 수 있었습니다. 

저의 경우에는 질문에 대한 답변을 하지 못했을 경우 그 질문에 대한 답변을 알려주실 수 있냐고 하였습니다. 프로페셔널한 개발자분들은 성심성의껏 답변해주시는 분들이 많았고 답을 틀렸다고 불합격을 주지도 않았습니다. 오히려 이런 열의를 좋게 봐주셔서 면접을 본 곳 모두 합격을 하였습니다.

개발자면서도 컴맹인 분들도 많아서 개발용어와 관련된 질문뿐만 아니라 정처기 필기에 나오는 전반적인 컴퓨터 + 개발에 대한 질문을 하는 곳은 개발자를 넘어 데브옵스의 영역까지도 전문적으로 깊이가 있는 사람이 상사라는 의미로 같이 일을 하면 초반엔 힘들 수는 있지만 본인은 정말 알다모르게 상사를 따라다니거나 질문을 통해 배우는 점이 많을 것입니다.

> **참고**: 직접 면접을 다니면서 받았던 기술질문에 대해서는 빨간색으로 표시를 해뒀습니다. 자주나오는 질문은 노란형광펜으로 색칠했습니다.

---

## 📑 목차

1. [운영체제](#1-운영체제)
2. [네트워크](#2-네트워크)
3. [데이터베이스](#3-데이터베이스)
4. [객체지향 프로그래밍](#4-객체지향-프로그래밍)
5. [Java](#5-java)
6. [Spring Framework](#6-spring-framework)
7. [웹 개발](#7-웹-개발)
8. [자료구조 & 알고리즘](#8-자료구조--알고리즘)
9. [개발 상식](#9-개발-상식)
10. [디자인 패턴](#10-디자인-패턴)

---

## 1. 운영체제

### Q. 운영체제란?

**A.** 시스템의 자원과 동작을 관리하는 소프트웨어입니다.
- 프로세스 관리
- 저장장치 관리
- 네트워킹 관리
- 사용자 관리
- 하드웨어 관리

### Q. 메모리 구조에 대해 설명하세요.

**A.** 메모리는 크게 4가지 영역으로 구분됩니다:

1. **Code 영역**: 소스코드가 저장되는 영역
2. **Data 영역**: 전역변수, 정적변수가 할당되는 영역
3. **Heap 영역**: 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 공간
4. **Stack 영역**: 함수의 호출 정보, 지역변수, 매개변수들이 저장되는 영역

### Q. 가상 메모리란?

**A.** 모든 프로세스에게 메모리를 할당하기에는 메모리의 크기에 한계가 있기 때문에 사용하는 방법입니다. 

- 프로세스에서 사용하는 부분만 메모리에 올리고, 나머지는 디스크에 보관하는 기법
- 물리적 메모리보다 큰 프로그램도 실행 가능
- 메모리 효율성 향상

### Q. 프로세스와 스레드의 차이점은?

**A.**

| 구분 | 프로세스 | 스레드 |
|------|---------|--------|
| 정의 | 운영체제로부터 자원을 할당 받는 작업의 단위 | 할당 받은 자원을 이용하는 실행 단위 |
| 관계 | 어플리케이션 하나가 프로세스 | 프로세스 안에서의 분기 처리 |
| 메모리 | 독립적인 메모리 공간 | 프로세스의 메모리 공유 |
| 통신 | IPC(Inter-Process Communication) 필요 | 공유 메모리로 통신 가능 |

### Q. 멀티프로세스와 멀티스레드의 차이점은?

**A.**

**멀티 프로세스**
- 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리
- **장점**: 하나의 프로세스가 잘못되어도 프로그램은 동작
- **단점**: Context Switching 비용 발생

**멀티 스레드**
- 프로그램을 여러 개의 스레드로 구성하고 스레드가 작업을 처리
- **장점**: 
  - 시스템 자원 소모 감소
  - 처리 비용 감소
  - 스레드간 자원 공유
- **단점**: 
  - 디버깅이 어려움
  - 동기화 이슈 발생
  - 하나의 스레드 오류로 전체 프로세스에 문제 발생

### Q. 스레드란?

**A.** 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다.

- 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행
- 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 함

### Q. Thread Safe란?

**A.** 스레드 안전을 뜻합니다.

- 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램 실행에 문제가 없음을 의미

---

## 2. 네트워크

### Q. 프로토콜이란?

**A.** 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계입니다.

### Q. TCP와 UDP의 차이점은?

**A.**

**TCP (Transmission Control Protocol)**
- 신뢰성 있는 통신을 위해 사용하는 프로토콜
- 높은 신뢰성을 보장하지만, UDP보다 속도가 느림
- 3-way, 4-way handshake로 서버와 클라이언트가 1:1로 통신
- 흐름 제어와 혼잡 제어가 이루어짐
- 연결형 프로토콜

**UDP (User Datagram Protocol)**
- 비연결형 프로토콜
- 손상된 데이터에 대해서 재전송하지 않음
- 신뢰성이 낮지만, TCP보다 속도가 빠름
- 스트리밍 같은 서비스에 주로 사용
- 1:1, 1:N, N:M으로 연결이 가능

### Q. IP란?

**A.** Internet Protocol의 약자로 인터넷 망을 통해 패킷을 전달하는 프로토콜입니다.

**특징:**
- **비연결성**: 패킷을 보내는 길을 정하지 않음
- **비신뢰성**: 패킷의 완전한 전달을 보장하지 않음

### Q. DNS란?

**A.** Domain Name System의 약자로, 도메인 주소를 IP 주소로 변환해주는 시스템입니다.

### Q. HTTP란?

**A.** HyperText Transfer Protocol의 약자로, 웹 상에서 클라이언트와 서버 간에 요청과 응답으로 데이터를 주고 받을 수 있는 프로토콜입니다.

### Q. HTTP 클라이언트 전달 과정은?

**A.** 
1. 클라이언트가 HTTP 프로토콜을 통해 서버에게 요청을 보냄
2. 서버는 요청에 맞는 응답을 클라이언트에게 전송
3. HTTP 요청에 포함되는 HTTP 메서드는 서버가 요청을 수행하기 위해 해야 할 행동을 표시하는 용도로 사용

### Q. GET vs POST 차이점은?

**A.**

**GET**
- 클라이언트에서 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 메서드
- 데이터를 읽거나, 검색할 때 사용
- URL에 파라미터가 포함됨
- 캐시 가능

**POST**
- 리소스를 생성, 업데이트 하기 위해 서버에 데이터를 보낼 때 사용
- GET과 달리 전송해야 되는 데이터를 body에 담아서 전송
- Content-Type에 요청 데이터 타입 표시에 따라 결정
- 캐시 불가능

### Q. CORS란?

**A.** Cross-Origin Resource Sharing의 약자로, 다른 출처(Origin)의 리소스를 공유하는 것을 의미합니다.

- 브라우저는 기본적으로 동일 출처 정책(Same-Origin Policy)에 따라 다른 출처의 리소스 접근을 제한
- CORS는 서버에서 특정 헤더를 통해 다른 출처의 접근을 허용하는 메커니즘

### Q. Preflight란? 헤더 이름은?

**A.** Preflight는 실제 요청 전에 브라우저가 보내는 사전 요청입니다.

- **OPTIONS 메서드**로 실제 요청 전에 서버에 허용 여부를 확인
- **CORS Preflight 헤더**:
  - `Access-Control-Request-Method`: 실제 요청에서 사용할 HTTP 메서드
  - `Access-Control-Request-Headers`: 실제 요청에서 사용할 헤더 목록
- 서버는 `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers` 등으로 응답

### Q. RESTful API란?

**A.** 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미합니다.

- URL을 통해 자원을 명시
- HTTP Method를 통해 해당 자원에 대한 CRUD를 적용
- **REST 원칙**:
  1. 리소스와 행위를 명시적이고 직관적으로 분리 (URI는 명사, HTTP Method는 동사)
  2. Message는 Header와 Body를 명확하게 분리
  3. API 버전 관리
  4. 서버와 클라이언트가 같은 방식을 사용

**장점:**
- Open API 제공이 쉬움
- 멀티플랫폼 지원 및 연동 용이
- 원하는 타입으로 데이터 주고받기 가능
- 기존 웹 인프라(HTTP) 그대로 사용

**단점:**
- 사용할 수 있는 메소드가 한정적
- 분산환경에는 부적합
- HTTP 통신 모델에 대해서만 지원

---

## 3. 데이터베이스

### Q. 데이터베이스를 사용하는 이유는?

**A.** 파일 시스템의 문제점을 해결하기 위해 사용합니다.

**데이터베이스의 특징:**
1. **데이터의 독립성**
   - 물리적 독립성: 데이터 파일 구조 변경 시 응용 프로그램 수정 불필요
   - 논리적 독립성: 다양한 응용 프로그램의 논리적 요구 만족
2. **데이터의 무결성**: 여러 경로를 통한 잘못된 데이터 발생 방지
3. **데이터의 보안성**: 인가된 사용자만 접근 가능
4. **데이터의 일관성**: 연관된 정보를 논리적 구조로 관리
5. **데이터 중복 최소화**: 통합 관리로 중복 문제 해결

### Q. 데이터베이스 성능 이슈는?

**A.** 데이터베이스 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작됩니다.

- **랜덤 I/O**: 디스크 헤더를 움직여 읽고 쓸 위치로 옮기는 작업 (느림)
- **순차 I/O**: 연속된 공간에 순차적으로 읽고 쓰는 작업 (빠름)
- 쿼리 튜닝의 목적은 랜덤 I/O를 줄여주는 것

### Q. 인덱스(Index)란?

**A.** 인덱스는 책의 색인과 같습니다. 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 만들어 두는 것입니다.

**특징:**
- 항상 정렬된 상태를 유지
- 데이터의 저장 성능을 희생하고 읽기 속도를 높임
- SELECT 쿼리문의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 역효과

**인덱스 자료구조:**
- **B+-Tree**: 일반적으로 사용되는 인덱스 알고리즘, 원래 값을 이용해 인덱싱
- **Hash**: 해시 값을 계산해서 인덱싱, 매우 빠른 검색이지만 전방 일치 검색 불가

**Primary Index vs Secondary Index:**
- **Primary Index**: Primary Key에 대해 생성된 인덱스, 테이블 당 하나만 존재
- **Secondary Index**: Primary Key가 아닌 다른 칼럼에 대해 생성된 인덱스, 테이블 당 여러 개 가능

**Clustered Index vs Non-clustered Index:**
- **Clustered Index**: 인덱스가 적용된 속성 값에 의해 레코드의 물리적 저장 위치가 결정, 테이블 당 한 개만 생성 가능
- **Non-clustered Index**: 데이터를 물리적으로 정렬하지 않음, 별도의 인덱스 테이블 생성, 테이블 당 여러 개 생성 가능

**인덱스 성능 고려사항:**
- INSERT, DELETE, UPDATE 시 인덱스도 함께 수정되어 성능 저하
- 데이터의 형식에 따라 인덱스 효율이 달라짐 (카디널리티가 높은 컬럼에 인덱스 생성 권장)

### Q. 정규화란?

**A.** 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업입니다.

**정규화 탄생 배경:**
- 한 릴레이션에 여러 엔티티의 애트리뷰트를 혼합하면 정보가 중복 저장되고 갱신 이상 발생
- **갱신 이상의 종류**:
  - 삽입 이상: 원하지 않는 자료 삽입 또는 자료 부족으로 삽입 불가
  - 삭제 이상: 하나의 자료만 삭제하고 싶지만 튜플 전체가 삭제됨
  - 수정 이상: 일부 튜플만 갱신되어 정보가 모호해짐

**정규형:**
- **제 1 정규형**: 애트리뷰트의 도메인이 오직 원자값만을 포함
- **제 2 정규형**: 모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해 완전 함수적 종속
- **제 3 정규형**: 비주요 애트리뷰트가 기본키에 대해 이행적으로 종속되지 않음
- **BCNF**: 비주요 애트리뷰트가 후보키의 일부를 결정하는 경우 분해

**정규화의 장점:**
- 데이터베이스 변경 시 이상 현상 제거
- 데이터베이스 구조 확장 시 재 디자인 최소화
- 사용자에게 데이터 모델을 더욱 의미있게 제공

**정규화의 단점:**
- 릴레이션의 분해로 인해 JOIN 연산이 많아져 질의 응답 시간이 느려질 수 있음

**반정규화:**
- 정규화된 엔티티를 성능 향상을 위해 중복 통합, 분리 등을 수행
- 조회에 대한 처리 성능이 중요할 때 부분적으로 고려

### Q. 트랜잭션(Transaction)이란?

**A.** 작업의 완전성을 보장해주는 것입니다. 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.

**트랜잭션의 ACID 특징:**

1. **A (Atomicity, 원자성)**: 한 트랜잭션 내 실행한 작업이 모두 성공하거나 또는 실패해야 함
2. **C (Consistency, 일관성)**: 트랜잭션 완료 후에도 데이터의 일관성을 보장해야 함
3. **I (Isolation, 격리성)**: 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 함
4. **D (Durability, 지속성)**: 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 함

**트랜잭션과 Lock:**
- **Lock**: 동시성을 제어하기 위한 기능, 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 처리
- **Transaction**: 데이터의 정합성을 보장하기 위한 기능, 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함

**트랜잭션 사용 시 주의할 점:**
- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋음 (트랜잭션 범위 최소화)
- 트랜잭션 범위가 길어지면 커넥션을 오래 소유하게 되어 다른 프로그램이 대기해야 할 수 있음

### Q. 교착상태(Deadlock)란?

**A.** 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태입니다.

**교착 상태의 빈도를 낮추는 방법:**
- 트랜잭션을 자주 커밋한다
- 정해진 순서로 테이블에 접근한다
- 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다

### Q. Statement vs PreparedStatement 차이는?

**A.**

**PreparedStatement**
- 쿼리를 수행하기 전에 이미 쿼리가 컴파일되어 있음
- 반복 수행 시 프리 컴파일된 쿼리를 통해 수행되어 빠름
- SQL Injection 공격 방지 가능

**Statement**
- 매번 쿼리를 파싱해야 함
- SQL Injection 취약

**결론:** SQL 파싱 시간은 전체 시간의 10분의 1에 불과하지만, SQL Injection 방지를 위해 PreparedStatement 사용이 권장됩니다.

### Q. NoSQL이란?

**A.** 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소입니다.

**CAP 이론:**
- **일관성(Consistency)**: 동시에 조회하는 데이터는 항상 동일한 데이터
- **가용성(Availability)**: 모든 클라이언트의 읽기와 쓰기 요청에 항상 응답 가능
- **네트워크 분할 허용성(Partition tolerance)**: 네트워크가 단절되어도 각 지역 내 시스템은 정상 동작

**저장 방식에 따른 분류:**
1. **Key-Value Model**: 키 하나로 데이터 하나를 저장하고 조회 (ex: Redis)
2. **Document Model**: 키에 구조화된 문서를 저장 (ex: MongoDB)
3. **Column Model**: 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 저장

---

## 4. 객체지향 프로그래밍

### Q. 절차지향과 객체지향의 차이점은?

**A.**

**절차지향**
- 수행되어야 할 연속적인 계산과 과정을 포함하고 있는 프로그래밍
- 중심이 컴퓨터에 있음

**객체지향**
- 강한 응집력과 약한 결합력을 위해 현실세계의 객체라는 개념을 이용한 프로그래밍
- 인간 중심적 프로그래밍 패러다임
- 현실 세계를 프로그래밍으로 옮겨와 프로그래밍

### Q. 객체지향 프로그래밍(OOP)이란?

**A.** 컴퓨터 프로그래밍 방식 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

### Q. 객체지향 프로그래밍의 장점과 단점은?

**A.**

**장점**
- **코드 재사용성**: 상속을 통해 코드의 재사용률을 높일 수 있음
- **유지보수 용이**: 수정해야 할 부분이 클래스 내부에 있기 때문에 수정이 편리
- **생산성 향상**: 잘 설계된 클래스를 독립적인 객체로 활용하여 생산성 향상
- **자연적인 모델링**: 일상생활의 개념을 객체 구조로 표현
- **신뢰성 확보**: 라이브러리 사용으로 컴파일 단계에서 에러 발견 가능
- **디버깅 용이**: 객체 단위로 코드가 나뉘어져 있음

**단점**
- **실행 속도**: 절차지향 언어에 비해 상대적으로 실행 속도가 느림
- **프로그램 용량**: 객체 단위로 프로그램을 많이 만들면 용량 증가
- **설계 시간**: 클래스, 객체, 상속 구조 설계에 시간이 많이 소요
- **Overhead**: 객체 간의 정보 교환이 메시지 교환을 통해 일어나므로 overhead 발생
- **상태 관리**: 객체가 상태를 갖기 때문에 예측할 수 없는 상태로 인한 버그 발생 가능

### Q. OOP의 4가지 원칙은?

**A.**

1. **캡슐화 (Encapsulation)**
   - 실제 구현 부분을 외부에 드러나지 않는 접근 제어자/인터페이스를 의미
   - 변수와 메서드를 하나로 묶고, 데이터를 외부에서 직접 접근하지 않고 함수를 통해서만 접근
   - **정보은닉**: 다른 객체에서 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용

2. **상속 (Inheritance)**
   - 이미 정의된 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

3. **추상화 (Abstraction)**
   - 인터페이스로 클래스들의 공통적인 특성들을 묶어 표현하는 것

4. **다형성 (Polymorphism)**
   - 하나의 참조 변수로 여러 타입의 객체를 참조할 수 있는 것

### Q. 오버로딩과 오버라이딩의 차이점은?

**A.**

**오버로딩 (Overloading)**
- 하나의 클래스에 같은 이름의 메서드를 여러 개 정의하는 것
- 메서드 이름은 같으나, 매개변수의 개수나 타입이 달라야 함

**오버라이딩 (Overriding)**
- 조상 클래스로부터 상속받은 메서드의 내용을 상속받는 클래스에 맞게 재정의 하는 것

### Q. SOLID 원칙에 대해 설명하세요.

**A.**

1. **SRP (Single Responsibility Principle, 단일 책임 원칙)**: 한 클래스는 하나의 책임만 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 함
2. **OCP (Open-Closed Principle, 개방-폐쇄 원칙)**: 소프트웨어 요소는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 함
3. **LSP (Liskov Substitution Principle, 리스코프 치환 원칙)**: 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함
4. **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**: 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 함
5. **DIP (Dependency Inversion Principle, 의존관계 역전 원칙)**: 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안됨

---

## 5. Java

### Q. Java 접근 제어자 종류는?

**A.**

| 접근 제어자 | 설명 |
|------------|------|
| `public` | 접근 제한이 없음 |
| `private` | 해당 클래스 내에서만 접근 가능 |
| `protected` | 같은 패키지 내에서와 다른 패키지의 자손 클래스에서 접근 가능 |
| `default` | 같은 패키지 내에서만 접근 가능 (접근 제어자를 지정하지 않을 때) |

### Q. 기본 접근제어자(default)와 protected 접근 제어자의 차이는?

**A.**

- **default**: 같은 패키지 안의 다른 클래스에서 볼 수 있지만 해당 패키지 이외의 클래스에서는 볼 수 없음
- **protected**: default와 동일하지만, protected 클래스를 상속한 클래스는 패키지 밖에서도 볼 수 있음

### Q. 생성자란?

**A.** 생성자는 클래스와 같은 이름의 메서드로, 새 객체가 생성될 때 호출되는 메서드입니다.

- 명시적으로 생성자를 만들지 않아도 default로 만들어짐
- 생성자는 파라미터를 다르게 하여 오버로드 할 수 있음
- 파라미터 생성자를 만든다면 파라미터가 없는 default형 생성자도 명시적으로 만들어주어야 함

### Q. 지역변수와 인스턴스변수의 차이는?

**A.**

- **지역변수**: 메서드 안에서 정의되어 메서드 안의 스코프 안에서만 존재
- **인스턴스 변수**: 클래스에서 정의되어 클래스 전체의 스코프 안에서 존재

### Q. Java 컴파일 과정은?

**A.**

1. 자바 소스 코드를 작성
2. 자바 컴파일러가 자바 소스 파일을 컴파일
3. 컴파일된 바이트 코드를 JVM의 클래스 로더에게 전달
4. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, 즉 JVM의 메모리에 올림
5. 실행 엔진은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행
   - 이때, 실행 엔진은 두 가지 방식으로 변경됨 (인터프리터, JIT 컴파일러)

### Q. JVM 구조에 대해 설명하세요.

**A.** JVM(Java Virtual Machine)이란 자바 가상 머신을 의미합니다.

**역할:**
- 자바와 OS 사이에서 중간자 역할을 수행
- 자바가 운영체제에 구애받지 않고 프로그램을 실행할 수 있도록 도와주는 역할
- 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행
- 레지스터 기반이 아닌 스택 기반으로 동작

**결과:** OS에 종속적이지 않고 Java 파일 하나만 만들면 어느 디바이스든 JVM 위에서 실행할 수 있음

### Q. 자바 애플리케이션 실행 과정은?

**A.**

1. 자바 소스 코드를 작성
2. 컴파일러가 자바 소스를 바이트코드로 변환
3. Class Loader가 바이트 코드를 런타임 데이터 영역에 로드
4. 로딩된 바이트 코드가 실행 엔진에 의해서 실행

### Q. 자바 메모리 구조는?

**A.** 자바 메모리 구조는 크게 5가지 영역으로 구분됩니다.

**스레드마다:**
- **PC Register**: 현재 수행중인 JVM 명령어가 들어감
- **JVM Stack**: 호출된 메서드의 매개변수, 지역변수, 리턴 정보들이 저장됨
- **Native Method Stack**: 자바 외의 언어인 C나 C++ 같은 것들을 수행하기 위한 영역

**스레드 공통:**
- **Method Area**: 클래스 별로 전역변수, 정적변수, 메서드 정보들이 저장됨
- **Heap**: 런타임 중 생성되는 객체들이 동적으로 할당되는 곳

### Q. 가비지 컬렉션(GC)이란?

**A.** JVM에서 메모리를 관리해주는 모듈입니다.

- Heap 메모리를 재활용하기 위해서 더 이상 참조되지 않는 객체들을 메모리에서 제거하는 모듈
- 개발자가 직접 메모리를 정리하지 않아도 되기 때문에 개발 속도가 향상되는 장점
- **단점**: Mark and Sweep 과정에서 참조되지 않는 객체를 찾는 과정이 있는데, 이 때 스레드가 잠깐 중단이 되어서 성능이 떨어짐

### Q. Java 8, 11, 17의 주요 차이는?

**A.**

**Java 8 (2014)**
- **Lambda 표현식**: 함수형 프로그래밍 지원
- **Stream API**: 컬렉션 처리의 함수형 스타일
- **Optional**: null 처리 개선
- **Default Method**: 인터페이스에 기본 구현 제공
- **Date/Time API**: 새로운 날짜/시간 API (java.time)

**Java 11 (2018) - LTS**
- **String 메서드 추가**: `isBlank()`, `lines()`, `strip()` 등
- **HTTP Client**: 표준 HTTP 클라이언트 API
- **로컬 변수 문법**: `var` 키워드 (타입 추론)
- **파일 I/O 개선**: `Files.readString()`, `Files.writeString()`

**Java 17 (2021) - LTS**
- **Sealed Classes**: 상속을 제한할 수 있는 클래스
- **Pattern Matching for switch**: switch 표현식 개선
- **Records**: 불변 데이터 클래스를 위한 간단한 문법
- **Text Blocks**: 멀티라인 문자열 지원

### Q. Stream API의 특징은?

**A.**

- **함수형 스타일**: 선언형 프로그래밍으로 데이터 처리
- **Lazy Evaluation**: 최종 연산이 호출될 때까지 중간 연산이 실행되지 않음
- **병렬 처리**: `parallelStream()`으로 병렬 처리 가능
- **불변성**: 원본 데이터를 변경하지 않음
- **체이닝**: 여러 연산을 연결하여 사용 가능

**주요 연산:**
- **중간 연산**: `filter()`, `map()`, `sorted()`, `distinct()` 등
- **최종 연산**: `collect()`, `forEach()`, `reduce()`, `count()` 등

### Q. Call by Value와 Call by Reference의 차이는?

**A.**

**Call by Value (값에 의한 호출)**
- 함수가 호출될 때 메모리 공간 안에서는 임시의 공간이 생성되고, 함수가 종료되면 해당 공간은 사라짐
- 함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달
- 복사된 인자는 함수 안에서 지역적으로 사용하는 변수

**Java의 경우:**
- **기본 자료형**: call by value로 동작 (int, short, long, float, double, char, boolean)
- **참조 자료형**: 참조 값 자체를 복사하여 전달 (Array, Class Instance)

**Call by Reference (참조에 의한 호출)**
- 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달 (해당 변수를 가리킴)
- 함수 안에서 인자의 값이 변경되면, 함수 호출시에 있던 변수들도 값이 바뀜

### Q. 추상 클래스와 인터페이스의 차이는?

**A.**

**추상 클래스**
- 부분적으로만 완성된 '미완성 설계도'
- 클래스 안에 '추상 메서드'가 하나 이상 포함되거나 abstract로 정의된 경우
- 그 추상 클래스를 상속 받아서 기능을 이용하여 확장할 수 있음
- 단일 상속만 가능

**인터페이스**
- 구현된 것은 아무것도 없고 '밑그림만 그려진 기본 설계도'
- 모든 메서드가 추상 메서드인 경우 (Java 8 이전)
- 함수의 껍데기만 있으며, 그 함수의 구현을 강제하기 위해서 사용
- 다중 상속 가능
- Java 8부터 default 메서드와 static 메서드 지원

### Q. 에러와 예외의 차이는?

**A.**

**예외 (Exception)**
- 프로그램의 코딩에서 수행된 실수의 결과
- 발생하더라도 비교적 덜 심각한 오류이므로 예외처리를 통해서 비정상적인 종료를 막을 수 있음

**에러 (Error)**
- 시스템의 부적절한 기능의 결과
- 메모리 부족, 스택오버플로우와 같이 발생하게 되면 복구 할 수 없는 심각한 오류

### Q. 체크 예외와 언체크 예외의 차이는?

**A.**

**체크 예외 (Check Exception)**
- 컴파일 단계에서 확인되는 예외
- 반드시 명시적으로 예외 처리를 해야 함
- 로직상 예외 발생 가능성이 있는 상황들을 표현
- 대표적으로 IOException, SQLException, ClassNotFoundException

**언체크 예외 (Uncheck Exception)**
- 실행 단계에서 확인되는 예외
- 명시적인 예외 처리를 강제하지 않음
- RuntimeException 클래스의 하위 클래스들이 모두 여기에 속함

### Q. Compiler vs Interpreter 차이는?

**A.**

**Compiler**
- 인간의 언어에 가까운 고급 언어를 기계어로 변환해주는 것
- 한 번의 번역을 함

**Interpreter**
- 런타임 이전의 기계어로 한 줄씩 번역
- 에러가 발생한다면, 즉각 에러가 표시가 되어 좋으나 코드의 변화에 있어서 Compiler에 비해 비효율적

### Q. 불변 객체란? Java String이 불변인 이유는?

**A.** 

**불변 객체**: 한번 생성되면 그 값이 변하지 않는 객체

**Java String이 불변인 이유:**
- 문자열 객체는 재 사용될 가능성이 높기 때문에 어플리케이션 당 하나의 String 객체만을 생성해두어 JVM의 힙을 절약하기 위해서
- String 객체의 캐싱 기능
- 보안 기능
- 스레드 안전성

### Q. String / StringBuilder / StringBuffer의 차이는?

**A.**

**String**
- 한번 값이 할당되면 그 공간은 변하지 않음 (불변)
- 값을 변화시킬 때, Heap에 새로운 메모리를 사용하고, 참조되는 메모리 주소만 바꿔주는 것
- 불변성을 가지기 때문에 멀티쓰레드 환경에서의 안정성(thread-safe)을 가짐

**StringBuffer**
- 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전함 (thread-safe)
- 단일쓰레드에서의 성능은 StringBuilder보다 떨어짐

**StringBuilder**
- 동기화를 지원하지 않기 때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않음
- 동기화를 고려하지 않는 만큼 단일쓰레드에서의 성능은 StringBuffer보다 뛰어남

### Q. 싱글톤 패턴이란?

**A.** 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴입니다.

- 하나의 인스턴스만을 생성하는 책임이 있음
- getInstance 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행

### Q. 제네릭이란? 사용하는 이유는?

**A.** 제네릭이란 '타입을 일반화'하는 것으로 클래스 내부에서 정하는 것이 아닌 사용자 호출에 의해 타입이 지정되는 것을 의미합니다.

즉, 특정 타입의 변수형에 지정되는 것이 아닌 필요에 의해 여러 가지 타입을 사용하고 싶을 경우 사용합니다.

**사용하는 이유:**
- 재사용성 증가
- 컴파일 시 타입 에러 발견 가능
- 컴파일러가 타입 변환 수행
- 강제 캐스팅 사용을 줄여 프로그램 성능 저하를 줄일 수 있음
- 반복되는 코드를 줄임으로써 가독성, 프로그램 크기, 유지보수를 효율적으로 할 수 있음

### Q. Servlet vs JSP 차이는?

**A.**

**Servlet**
- 자바 언어로 웹 개발을 위해 만들어짐
- Container가 이해할 수 있게 구성된 순수 자바 코드로 만듦

**JSP**
- HTML 기반에 Java 코드를 블록화하여 삽입한 것
- Servlet을 좀 더 쉽게 접근할 수 있도록 만들어짐

### Q. List, Set, Map의 차이는?

**A.**

| 구분 | List | Set | Map |
|------|------|-----|-----|
| 저장 방식 | 순차적으로 저장 | 순서없이 key로만 저장 | 순서없이 key, value로 저장 |
| 중복 | 데이터 중복 허용 | key의 중복 허용 X | value는 중복 허용, key는 중복 허용 X |
| null | 데이터로 null 허용 | key로 null 허용 X | key는 null 허용 X |

### Q. ArrayList vs LinkedList 차이는?

**A.**

**ArrayList**
- 데이터들이 순서대로 늘어선 배열의 형식
- 논리적 저장 순서와 물리적 저장 순서가 일치
- 인덱스로 해당 원소에 접근 가능 (Random Access)
- **시간 복잡도**: 
  - 접근: O(1)
  - 삽입/삭제: O(n) - shift 작업 필요

**LinkedList**
- 자료의 주소값으로 서로 연결된 형식
- 논리적 저장 순서와 물리적 저장 순서가 일치하지 않음
- 원하는 위치에 삽입/삭제 시 Search 과정 필요
- **시간 복잡도**:
  - 접근: O(n)
  - 삽입/삭제: O(1) - 위치를 알고 있다면, O(n) - 위치를 찾아야 한다면

**사용 시나리오:**
- **ArrayList**: 접근이 빈번하고 삽입/삭제가 적을 때
- **LinkedList**: 삽입/삭제가 빈번하고 접근이 적을 때

### Q. 큐와 스택의 구현 방법은?

**A.**

**큐 (Queue)**
- First In First Out (FIFO)
- Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요
- List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 LinkedList로 구현하는 것이 좋음

**스택 (Stack)**
- Last In First Out (LIFO) 또는 First In Last Out (FILO)
- List로 구현하면 객체를 제거하는 작업이 필요
- Array로 구현하면 삭제할 필요없이 index를 줄이고 초기화만 하면 되므로 Array로 구현하는 것이 좋음

---

## 6. Spring Framework

### Q. 스프링 프레임워크란?

**A.** 자바 플랫폼을 위한 오픈 소스 어플리케이션 프레임워크입니다.

- 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공
- 대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자정부표준 프레임워크의 기반 기술

### Q. 스프링 프레임워크와 스프링 부트의 차이는?

**A.**

**Spring Framework**
- 복잡한 설정이 필요 (XML, Java Config)
- 의존성 관리가 복잡함
- 여러 모듈을 선택적으로 사용
- Tomcat 등 서버를 별도로 설치하고 설정해야 함

**Spring Boot**
- 자동 설정(Auto Configuration) 제공
- 내장 서버(Tomcat) 포함
- Starter를 통한 간편한 의존성 관리
- 프로덕션 준비 기능 제공 (Actuator)
- 설정 최소화로 빠른 개발 가능

**결론:** Spring Boot는 Spring Framework를 더 쉽게 사용할 수 있도록 만든 도구입니다.

### Q. 스프링 프레임워크의 특징은?

**A.**

1. **DI (Dependency Injection, 의존성 주입)**
   - 설정 파일이나 어노테이션을 통해 객체 간의 의존 관계를 설정하여 개발자가 직접 의존하는 객체를 생성할 필요가 없음

2. **Spring AOP (Aspect-Oriented Programming, 관점지향 프로그래밍)**
   - 트랜잭션, 로깅, 보안 등 여러 모듈, 여러 계층에서 공통으로 필요로 하는 기능의 경우 해당 기능을 분리해 관리할 수 있음

3. **POJO (Plain Old Java Object)**
   - 일반 J2EE 프레임워크에 비해 특정 라이브러리를 사용할 필요가 없어 개발이 쉬움

4. **IOC (Inversion of Control, 제어의 역전)**
   - 컨트롤의 제어권이 개발자가 아니라 프레임워크에 있음
   - 객체의 생성부터 모든 생명 주기의 관리까지 프레임워크가 주도

### Q. Spring DI 주입 3가지 방법은? 어떤 것이 가장 좋은가?

**A.**

**1. 생성자 주입 (Constructor Injection)**
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**2. 필드 주입 (Field Injection)**
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

**3. Setter 주입 (Setter Injection)**
```java
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**가장 좋은 방법: 생성자 주입**

**이유:**
- **불변성**: final 키워드 사용 가능하여 불변 객체 생성
- **순환 참조 방지**: 애플리케이션 구동 시 순환 참조를 감지
- **테스트 용이**: Mock 객체를 쉽게 주입 가능
- **필수 의존성 명확**: 생성자에 필수 의존성이 명확히 드러남
- **Null 안전성**: 필수 의존성이 없으면 객체 생성 자체가 불가능

### Q. Spring AOP가 무엇인지 OOP와 AOP를 비교 설명하세요.

**A.**

**AOP (Aspect-Oriented Programming, 관점지향 프로그래밍)**
- 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법

**OOP (Object-Oriented Programming, 객체지향 프로그래밍)**
- 공통적 기능을 모든 모듈에 적용하기 위한 방법으로 상속을 이용하는데 Java에서는 다중 상속이 불가
- 기능 구현 부분에서 핵심 코드와 공통 코드가 섞여있어서 보기에도 불편하고 효율성이 떨어짐

**이러한 이유로 AOP가 등장했습니다.**

### Q. Filter와 Interceptor의 차이는?

**A.**

**Filter (필터)**
- **위치**: Servlet Container 레벨에서 동작
- **실행 시점**: DispatcherServlet 이전에 실행
- **용도**: 요청/응답의 전역적인 처리 (인코딩, CORS, 보안 등)
- **구현**: `javax.servlet.Filter` 인터페이스 구현
- **예시**: 인코딩 필터, 보안 필터

**Interceptor (인터셉터)**
- **위치**: Spring Container 레벨에서 동작
- **실행 시점**: DispatcherServlet과 Controller 사이에서 실행
- **용도**: 핸들러(Controller)에 대한 전처리/후처리
- **구현**: `HandlerInterceptor` 인터페이스 구현
- **예시**: 로그인 체크, 권한 확인

**실행 순서:**
1. Filter (pre)
2. DispatcherServlet
3. Interceptor (pre)
4. Controller
5. Interceptor (post)
6. Interceptor (afterCompletion)
7. Filter (post)

### Q. Spring MVC란?

**A.** 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

- **Model**: 애플리케이션이 무엇을 할 것인지를 정의하고, 내부 비즈니스 로직을 처리하기 위한 역할
- **View**: 사용자에게 보여지는 화면을 나타내며, 사용자 인터페이스 내의 구성 요소들을 표현
- **Controller**: Model과 View를 연결하고 있는 클래스를 대표하고 있으며, 클래스들 간의 정보를 교환하는 역할

---

## 7. 웹 개발

### Q. MVC에 대해 설명하세요.

**A.**

- **M (Model)**: 내부 비즈니스 로직에 해당
  - 백그라운드 로직으로써 처리되는 알고리즘, 데이터, DB와의 상호 작용 등을 담당

- **V (View)**: 사용자 인터페이스(UI)를 의미
  - 요청에 대한 처리 결과를 View를 통해 클라이언트에게 화면을 통해 보여줌

- **C (Controller)**: Model과 View 사이에서 중계자 역할을 수행
  - 클라이언트의 요청을 처리하고 흐름 제어를 담당

### Q. 쿠키와 세션에 대해 설명하세요.

**A.**

**쿠키 (Cookie)**
- 사용자의 컴퓨터에 저장하는 기록 정보 파일
- 클라이언트 로컬에 정의되는 키와 값이 들어있는 작은 데이터 파일
- 사용자 인증 유효시간 명시
- 유효시간이 정해지면 브라우저가 종료되어도 유지
- 쿠키로 인하여 페이지 이동 시마다 로그인을 다시 하지 않고, 사용자 정보를 유지할 수 있음

**세션 (Session)**
- 일정 시간 동안 같은 사용자로부터 일련의 요구를 하나의 상태로 보고 유지를 시킴
- 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 서버 측에서 관리
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증 상태를 유지

### Q. AccessToken과 RefreshToken의 개념은?

**A.**

**AccessToken (액세스 토큰)**
- 사용자 인증 후 발급되는 토큰
- API 요청 시 인증 정보로 사용
- **짧은 수명** (보통 15분 ~ 1시간)
- 만료되면 RefreshToken으로 재발급

**RefreshToken (리프레시 토큰)**
- AccessToken을 재발급하기 위한 토큰
- **긴 수명** (보통 7일 ~ 30일)
- 서버에 안전하게 저장 (DB 또는 Redis)
- AccessToken 만료 시 RefreshToken으로 새로운 AccessToken 발급

**동작 방식:**
1. 사용자 로그인 → AccessToken + RefreshToken 발급
2. API 요청 시 AccessToken 사용
3. AccessToken 만료 시 RefreshToken으로 재발급
4. RefreshToken도 만료되면 재로그인 필요

**장점:**
- 보안성 향상: AccessToken의 짧은 수명으로 탈취 위험 감소
- 사용자 편의성: 자주 로그인할 필요 없음

### Q. JSTL은 무엇이며, 사용하는 이유는?

**A.** JSP Standard Tag Library의 약자로서, 자신만의 태그를 추가할 수 있는 기능을 제공합니다.

- 주로 JSTL의 core에서 c를 사용하여 `<c:if>`, `<c:forEach>` 등으로 사용

### Q. Ajax란? 그리고 단점은?

**A.** Asynchronous JavaScript and XML의 약자로, 자바스크립트의 라이브러리 중 하나입니다.

- 전체 페이지를 새로 고치지 않고도 페이지의 일부분만을 위한 데이터를 로드하는 기법
- 자바스크립트를 사용한 비동기 통신
- 클라이언트와 서버 간에 XML 데이터를 주고받는 기술

**단점:**
- 자바스크립트이므로 브라우저에 따라 크로스 브라우저 처리가 필요
- 연속적인 데이터 요청 시 서버 부하가 증가하여 페이지가 느려짐
- 페이지 내 복잡도가 증가하여 에러 발생 시 디버깅이 어려움

### Q. 동기와 비동기의 차이는?

**A.**

**동기 (Synchronous)**
- 요청과 결과가 동시에 이루어지는 것
- 설계가 매우 간단하고 직관적
- 결과가 주어질 때까지 아무것도 하지 못 하고, 대기해야 한다는 단점

**비동기 (Asynchronous)**
- 요청과 결과가 동시에 일어나지 않음
- 동기보다 복잡하지만, 결과가 주어지는 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점

---

## 8. 자료구조 & 알고리즘

### Q. Array vs Linked List 차이는?

**A.**

**Array (배열)**
- 논리적 저장 순서와 물리적 저장 순서가 일치
- 인덱스로 해당 원소에 접근 가능 (Random Access)
- **시간 복잡도**: 
  - 접근: O(1)
  - 삽입/삭제: O(n) - shift 작업 필요

**Linked List (연결 리스트)**
- 논리적 저장 순서와 물리적 저장 순서가 일치하지 않음
- 각 원소는 자기 자신 다음에 어떤 원소인지만 기억
- 원하는 위치에 삽입/삭제 시 Search 과정 필요
- **시간 복잡도**:
  - 접근: O(n)
  - 삽입/삭제: O(1) - 위치를 알고 있다면, O(n) - 위치를 찾아야 한다면

### Q. Stack과 Queue란?

**A.**

**Stack (스택)**
- Last In First Out (LIFO) 또는 First In Last Out (FILO)
- 선형 자료구조의 일종
- 차곡차곡 쌓이는 구조로 먼저 들어간 원소는 맨 바닥에, 늦게 들어간 원소는 위에 쌓임
- 가장 위에 있는 원소가 호출됨

**Queue (큐)**
- First In First Out (FIFO)
- 선형 자료구조의 일종
- 먼저 들어간 원소가 맨 앞에서 대기하고 있다가 먼저 나옴

### Q. Tree란?

**A.** 트리는 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조입니다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조입니다.

**트리 구성 요소:**
- **Node (노드)**: 트리를 구성하고 있는 각각의 요소
- **Edge (간선)**: 노드와 노드를 연결하는 선
- **Root Node (루트 노드)**: 트리 구조에서 최상위에 있는 노드
- **Terminal Node (단말 노드)**: 하위에 다른 노드가 연결되어 있지 않은 노드
- **Internal Node (내부노드)**: 단말 노드를 제외한 모든 노드

**Binary Tree (이진 트리)**
- 루트 노드를 중심으로 두 개의 서브 트리로 나뉨
- 나뉘어진 두 서브 트리도 모두 이진 트리여야 함

**BST (Binary Search Tree)**
- 이진 트리의 일종
- **규칙**:
  1. 노드에 저장된 키는 유일
  2. 부모의 키가 왼쪽 자식 노드의 키보다 큼
  3. 부모의 키가 오른쪽 자식 노드의 키보다 작음
  4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리
- **시간 복잡도**: 평균 O(log n), 최악 O(n) - 편향 트리인 경우

### Q. Binary Heap이란?

**A.** 자료구조의 일종으로 Tree의 형식을 하고 있으며, 배열에 기반한 Complete Binary Tree입니다.

- **Max Heap**: 각 노드의 값이 해당 children의 값보다 크거나 같음
- **Min Heap**: 각 노드의 값이 해당 children의 값보다 작거나 같음
- **시간 복잡도**: 
  - 최대값/최소값 찾기: O(1)
  - 삽입/삭제: O(log n)

### Q. Red-Black Tree란?

**A.** RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식의 자료구조입니다.

- Search, Insert, Delete에 O(log n)의 시간 복잡도
- 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄임

**Red-Black Tree의 정의:**
1. 각 노드는 Red or Black 색깔을 갖음
2. Root node의 색깔은 Black
3. 각 leaf node는 black
4. 어떤 노드의 색깔이 red라면 두 개의 children의 색깔은 모두 black
5. 각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black nodes를 포함

### Q. Hash Table이란?

**A.** hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖습니다.

- 특정한 값을 Search 하는데 데이터 고유의 인덱스로 접근하게 되므로 average case에 대하여 Time Complexity가 O(1)
- **Hash Function**: 저장할 데이터와 연관된 고유한 숫자를 만들어 내는 알고리즘
- **Hashcode**: Hash Function에 의해 반환된 데이터의 고유 숫자 값

**Collision (충돌) 해결 방법:**

1. **Open Addressing (개방주소법)**
   - 해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입
   - Linear Probing, Quadratic Probing, Double Hashing Probing

2. **Separate Chaining (분리 연결법)**
   - 해시 충돌이 발생하면 해당 bucket의 list에 추가
   - 연결 리스트 또는 트리(Red-Black Tree)를 사용
   - Java 7에서는 연결 리스트 사용, Java 8부터는 데이터 개수가 8개 이상이면 트리 사용

**해시 버킷 동적 확장:**
- 데이터 개수가 해시 버킷의 개수의 75%가 되면 해시 버킷 크기를 두 배로 확장
- 0.75는 load factor라고 불림

### Q. Graph란?

**A.** 정점(Vertex)과 간선(Edge)의 집합입니다. 트리 또한 그래프이며, 그 중 사이클이 허용되지 않는 그래프를 말합니다.

**Graph 용어:**
- **Undirected Graph**: 정점과 간선의 연결관계에 있어서 방향성이 없는 그래프
- **Directed Graph**: 간선에 방향성이 포함되어 있는 그래프
- **Degree**: Undirected Graph에서 각 정점에 연결된 Edge의 개수
- **Weight Graph**: 간선에 가중치 정보를 두어서 구성한 그래프

**Graph 구현:**
- **인접 행렬 (Adjacent Matrix)**: 정방 행렬을 사용, O(1)로 연결 관계 파악, O(V²) 공간 복잡도
- **인접 리스트 (Adjacent List)**: 연결 리스트를 사용, O(E+V) 공간 복잡도

**Graph 탐색:**
- **DFS (Depth First Search)**: 깊이 우선 탐색, Stack 사용, O(V+E)
- **BFS (Breadth First Search)**: 너비 우선 탐색, Queue 사용, O(V+E)

---

## 9. 개발 상식

### Q. 좋은 코드란 무엇인가?

**A.** 좋은 코드의 기준은 다양하지만, 일반적으로 다음과 같은 특징을 가집니다:

- **읽기 쉬운 코드**: 다른 개발자가 이해하기 쉬운 코드
- **중복이 없는 코드**: DRY (Don't Repeat Yourself) 원칙 준수
- **테스트가 용이한 코드**: 단위 테스트 작성이 쉬운 코드
- **유지보수가 쉬운 코드**: 변경이 용이한 코드
- **명확한 네이밍**: 변수명, 함수명이 명확한 코드

### Q. TDD란?

**A.** Test-Driven Development(테스트 주도 개발)는 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스입니다.

**TDD 사이클:**
1. **Add a test**: 새로운 기능을 추가하기 전 테스트를 먼저 작성
2. **Run all tests and see if new one fails**: 모든 테스트를 실행하고 새로운 테스트가 실패하는지 확인
3. **Write code**: 테스트를 통과하는 가장 간단한 코드 작성
4. **Refactor code**: 코드 리팩토링

**장점:**
- 요구사항에 집중할 수 있음
- 기존 기능이 잘 작동하는지 확인 가능
- 리팩토링 시 안심하고 진행 가능
- 코드 퀄리티 향상

**단점:**
- 코드 생산성에 문제가 있을 수 있음 (코드량 증가)
- 테스트 코드 작성의 진입 장벽
- 모든 상황에 대해 테스트 코드를 작성할 수 없음

### Q. 함수형 프로그래밍이란?

**A.** 함수형 프로그래밍의 가장 큰 특징 두 가지는 `immutable data`와 `first class citizen으로서의 function`입니다.

**Immutable vs Mutable:**
- **Immutable**: 변경 불가능함, 값이 변경될 경우 새로운 객체를 생성하고 변경된 값을 주입하여 반환
- **Mutable**: 해당 객체의 값이 변경될 경우 값을 변경

**First-class citizen:**
- 함수를 변수나 데이터 구조안에 담을 수 있음
- 함수의 파라미터로 전달할 수 있고, 함수의 반환값으로 사용 가능
- 함수를 리터럴로 바로 정의할 수 있음

### Q. Git과 GitHub에 대해서

**A.**

**Git**
- VCS(Version Control System)로 소스 코드의 버전을 관리하는 도구
- 분산 버전 관리 시스템

**GitHub**
- Git을 사용하는 프로젝트를 위한 웹 기반 호스팅 서비스
- 코드 저장소, 협업 도구, 이슈 트래킹 등 제공

**Git 전략:**
- **Gitflow**: master, develop, feature, release, hotfix 브랜치 사용
- **GitHub flow**: master 브랜치와 feature 브랜치만 사용하는 간단한 전략
- **GitLab flow**: 환경별 브랜치를 사용하는 전략

---

## 10. 디자인 패턴

### Q. 디자인 패턴에 대해서 아는 것을 말해보세요.

**A.** 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제에 대한 재사용 가능한 해결책입니다.

**주요 디자인 패턴:**

**1. 싱글톤 패턴 (Singleton Pattern)**
- 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하는 패턴
- getInstance 메서드를 통해 동일한 인스턴스 반환

**2. 팩토리 패턴 (Factory Pattern)**
- 객체 생성 로직을 분리하여 클라이언트 코드와 결합도를 낮추는 패턴
- 객체 생성의 책임을 팩토리 클래스에 위임

**3. 전략 패턴 (Strategy Pattern)**
- 알고리즘을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 패턴
- 클라이언트는 전략을 선택하여 사용

**4. 옵저버 패턴 (Observer Pattern)**
- 객체의 상태 변화를 관찰하는 관찰자들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 관찰자에게 통지하도록 하는 패턴

**5. 어댑터 패턴 (Adapter Pattern)**
- 호환되지 않는 인터페이스를 가진 클래스들을 함께 작동하도록 해주는 패턴

**디자인 패턴의 목적:**
- 코드 재사용성 향상
- 유지보수 용이성
- 확장성
- 코드의 가독성 향상

---

## 📌 면접 팁

- 질문에 대한 답변을 모를 경우, 질문에 대한 답변을 알려주실 수 있냐고 물어보는 것이 좋습니다.
- 프로페셔널한 개발자분들은 성심성의껏 답변해주시는 분들이 많고, 답을 틀렸다고 불합격을 주지도 않습니다.
- 오히려 이런 열의를 좋게 봐주시는 경우가 많습니다.
- 모르는 것을 아는 것처럼 말하지 말고, 솔직하게 모른다고 말하되, 관련된 지식이라도 말해보는 것이 좋습니다.
- 질문을 정확히 이해했는지 확인하고 답변하는 것이 중요합니다.

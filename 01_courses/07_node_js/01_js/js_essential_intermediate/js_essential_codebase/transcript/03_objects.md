### Objects: A practical introduction
 
- JavaScript is a prototype based object oriented programming language. That means, at its core, when we work with JavaScript, we're working with objects, and these objects are based on prototype. which is a very technical and confusing way of saying JavaScript works very much the same way we humans work with objects in the real world. So the quickest path to understanding JavaScript is through understanding objects and how they work. Because an object in JavaScript is pretty much the same as an object in real life, except it's written in code instead of created as a physical object. Let me show you what I mean using my backpack. This backpack is an object. This object has many identifiable properties like color, size, et cetera. We can give all of these properties recognizable names and then use them to describe this individual backpack objects. This backpack has the color gray. That's a property. If we fill it all the way up, we'll discover its volume is 30 liters. Another property. It has a bunch of pockets, 15 I think, that's a property. It has seven straps as a property, et cetera, et cetera. Object properties define the specifics of this one particular object. That way, I can have several backpacks, and why they're all backpacks, each has its own set of properties which makes that backpack a unique object. Now, I said JavaScript is a prototype based object oriented programming language. That means, each object is a unique instance of an object prototype. I have a lot of backpacks. The reason I can say they're all backpacks is they share common properties which define them as belonging to the backpack category. They all have two straps on one side, I can put my arms through. The area behind those straps is flat so it fits comfortably against my back. And they all have an opening at the top. This properties describe the prototype of a backpack and the particular combination and configuration of these properties define each individual backpack. This object prototype makes it easy to identify an existing bag as a backpack. You can check to see if it has the properties that match the prototype, and makes it easy to create a new backpack. Simply describe it by filling the property values. This prototype based object orientation allows us to do in programming, what we as humans do every time we encounter a new object and catalog it in our minds. We look at it, note its properties and think, this thing has the same collection of properties as this other thing I already know. So even though it is a different thing in appearance, the similarities in properties means its the same object type. And there's more, objects can have features built into them allowing us to change their property values. This backpack has several such features. A lid that can be opened and closed, a zipper to open and close the left and right sides, Strap adjusters to change the strap length, et cetera. In JavaScript, these property changing features inside an object are called methods. Which makes sense if you think about it, there's a method for opening and closing the backpack, a method for lengthening the straps and so on. These methods act on the current object only. So if I open this backpack using its top access method nothing happens to this other backpack because it's an entirely separate object. Oh, and one final thing, objects can contain other objects. So inside this backpack object, there is another object, a headlamp. And because the headlamp object is inside the backpack object, it is quite literally a property of the backpack object for as long as it's in there. This headlamp has its own set of properties, color, size, battery status, et cetera, and has its own set of methods, I can turn the light on and off, I can adjust the strap, I can charge it and so on. The headlamp object like the backpack object is a unique and separate object. It can be included inside another object, or it can be separate. There can be one or many of them and changing one object does not change the others. This mental model of objects described by their unique properties based on an object prototype whose individual properties can be modified using internal methods, is what I want you to keep front of mind as we explore JavaScript together.

### JavaScript objects: The code version
 
- To describe our real world objects, the backpack in JavaScript, we can use a JavaScript object. JavaScript objects are collections of data and functionality stored as properties and methods that describe the object and what it can do. To define an object, to create it, I first need a variable to hold the object. The modern convention here is to create a constant and we'll talk more about variables and constants later on in the course. So for now, just think of it as a box that we put the object inside. I give the constant the name, backpack, so we can refer back to it. So anytime we say backpack, we are now referring to the object. And then I use the equal symbol to assign a value to the constant, essentially filling the box. What I fill the box with is these two curly brackets. The curly brackets say this is a JavaScript object. And currently the JavaScript object is empty. So I need to populate my object with some data. This is done using properties. Each property is a name value pair, separated by a colon. The value can be many different things. It can be a text string inside quotation marks like right here. It can be a number, or a Boolean true false value, an array, or it can even be another object, as you see in the strap length example. An object can have as many properties as you like. You separate them using a comma. And the convention is to add each new property on its own line so it's easy to read what's going on inside the object. An object can also have methods used to change the properties of the object. These methods are also named value pairs. Only in a method, the value is a function or a call to a function. Calling the method from outside the object triggers whatever function is contained within that method. In this example, we have the toggleLid method. It contains a function that grabs a value for lidStatus, and then says this, so the current object's, lidOpen, should be changed to whatever's contained inside the lidStatus. You'll remember previously in the course I used this exact function to change the value of the lidOpen property from false to true. Finally, when you work with objects, you'll often see the, this, keyword used. The this keyword, simply refers to the current object. So we're saying this object right here. That way we're referring to the context of the current object and not some other object. So this lidOpen, lidStatus just means the current object's lidOpen property, should be changed to the value of lidStatus. What you see here is a JavaScript object version of my real world object, the backpack. It's properties describe what makes this backpack unique. And the methods allow us to change the changeable properties like whether the lid is open or closed and how long the strap length is.

### Object containers
 
- Now that we have an overview, let's dig a little bit deeper and really understand how an object fits together. The object needs somewhere to live and it needs a name. For this, we use a container called a variable. And in this case, it's a constant variable. The const keyword says, this is a constant. The name is the name we use to reference this particular container. And whatever's on the right hand side of the equal symbol is what goes inside the container, what is assigned to that container or to that variable. In this case, an object. Now this is a constant, meaning while we can change the properties of the object inside the container, we can't remove or replace the object from the container. If we try to do so by calling the constant name and using the equal symbol to set the contents to something else, the browser will tell us you can't do that. This is a constant. Let me show you. In the exercise files for this movie 0303, we have the backpack object. If I go into my browser and go to the console, I can console log out the backpack by just typing out backpack. Here, you see the full backpack object and we have access to all this data. Now we can try to assign something else to the backpack constant. So I'll say backpack equals, whoops. Backpack equals five. Now this is a variable so technically I should now remove the object entirely and just put the number five in its place. But if I run this, I get an uncaught type error, assignment to constant variables, saying this is a constant. You can't do this. You can't change its contents. And this is the reason why we use constants for objects. Once we've created an object, we might want to change its properties, but we never want to change it to something entirely different. Speaking of properties, I can change its properties. So for example, right now, the volume is at the 30. I can then say backpack dot volume and then set it to 50 and then just call backpack again. And you'll see now the volume is 50 instead. So even though it's in the constant, the properties are not constant. I just can't assign something altogether different to that constant. That way I can't accidentally destroy my objects while working with them.

### Object properties
 
- [Instructor] Properties are literally the properties of the object. They describe different aspects of the object. Object properties are defined using a colon separated name value pair, where the name can be any string and is placed on the left. And the value can be any string inside quotation marks or an integer or a floating point number or a Boolean value as a true or false or an array, or even another object, placed on the right. You control the property names. And in JS the standard states, a property name can only contain letters, digits, dollar signs, and underscores. If you add quotation marks or hyphens or other symbols the object will not function properly and JavaScript will crash because there'll be incorrect code inside the object definition. The rule of thumb here to make sure everything works properly is to simply use camel case for property names.

### Accessing objects
 
- [Narrator] In the real world, if you want someone to hand you something you mentioned it by name. So you say, hey, can you hand me that backpack, please? The same thing goes for JavaScript. Anytime you want to access an object or anything else contained inside a variable you simply call it by its name and JavaScript will hand it to you. In the exercise files for this movie there is an object with the name backpack. If you go over to the console you can call that object by simply naming it directly. So if I type in backpack here and hit return I get the entire object and I can then dig deeper into it to see what's going on. So here I can see all the properties and the methods and I can even open the methods to see what they contain. It works the same way in JavaScript. So let's say you want to output this object in its entirety in the console for reference and do so automatically so you don't have to go into the console and call it by name. JavaScript has a series of console methods for this purpose. And the most common one is called console log. Let me make some space here. And then we simply say, console log backpack. Save this. Go back in the browser. And now you see the backpack object outputs in the console automatically. If I reload the page you'll see it keeps popping in and we get the same thing. Here's the entire backpack object and we can get access to it automatically. So this code down here tells the browser grab the object and log it in the console. Now that you see how it works we can provide some additional context here by adding a string of text, explaining what it is, because if we look at this output right now, it's not very helpful. We can see there's an object we don't know which object it is and everything like that. So I can go into the console log here and add a string of text to the front, to say the backpack object colon then end my quotation mark, and add a comma. This format tells the console output first this string of text then add a space and then add the object in question. So we'll save that, go back in the browser. And now we can see it says the backpack object and then we have the object itself. So this is a really simple way of outputting context into the console so we can see what's going on and then providing context. So calling an object by its name in JavaScript is effectively the same thing as picking up an object in the real world. You now have the entire object and all its properties and functions.

### Accessing object properties
 
- [Instructor] Accessing an entire object is useful in some cases, but in other cases you need access to individual properties and methods within that object. There are two ways of accessing object properties, dot notation and bracket notation. Let's look at dot notation first. I want to output the value of just the pocket number property. To do that, I'll first console logout, the pocketNum value:, then I'll use dot notation by first accessing the backpack object, then adding a dot, and then adding the property I want, in this case pocket number. And you can see when I add the dot, VS Code automatically says, "Hey I see you're using dot notation. What is it you want?" And it suggests to me pocket number. Save, check it in the console, and you see now we have the full object, and then we have just a pocket number value. Dot notation is called dot notation because you literally use a dot to separate the different properties. So here we're digging one level in. So we're grabbing the backpack object, and then saying dot, just the property name. We can also use it to dig further into the object. If you look at the object here, you'll see the strapLength property has its own object inside it. with the values left and right. So if I wanted to output just the left strapLength value I can console logout, let's say, Strap length :L and then I say backpack, that's the object, then I want the strapLength property, and then inside the strapLength property, I want the left property. Save. And now we have that value as well, Strap length L: 26. Dot notation is the preferred way of accessing object properties because it's easy to read and understand. When I look at this, I immediately see, Oh, it's an object. And I'm looking for the strapLength property inside that object, and then the left property inside the strapLength property. So when you see a string like this with dots, you know you're accessing properties inside an object. However, in some cases you need more control, either because you want to use a variable as the property name, or because the property name is non-standard for some reason. For this, we have bracket notation. Let's look at how that works. So I'll copy this line here and then paste it in down here. Then to use bracket notation, I need to wrap the property name in quotation marks, because it's a string, and then square brackets. So if I highlight it, I can do quotation marks, and then I'll take the dot away, and put in the square bracket and whoops, put in a square bracket in its place like this. So as again see, the bracket notation is more clunky, but it also gives us more control. Save this output in the browser, and we have the pocketNum value again here. Now like I said, bracket notation allows us to do more advanced things. So let's say for example you want to pass the property value as a variable. You may have a function that outputs a specific value, and then you want to use that value. So for now, let's just say we want to set up a variable called query, and then we set that query to one of these values. We can set it to pocket number. Then, inside this bracket notation, I can use that query variable instead of a string. So what I'm doing now is saying, go and find the query variable, and then put the value of this variable inside here. So I need to put this in a string so that it works correctly. Save that, check it in the console, and it works the same way as before. What you see here can't be done using dot notation. If you place a variable inside dot notation, the script will simply break, because you're doing something incorrect. That's why we have this bracket notation. It gives us more control and allows us to do more things. There's also one additional situation where you might need to use bracket notation. In JavaScript, the standard states that a property name can only contain letters, digits, dollar signs, and underscores. However, nothing actively prevents you or a piece of software from creating property names that break these conventions. So in theory, we could encounter a property name that starts with a digit, or it contains quotation marks or something else. When using dot notation, you can't access that property if it starts with a number, or uses a hyphen, or otherwise breaks the standard, because everything will break. In this circumstance, bracket notation comes to the rescue, because you are passing a quoted string that can be literally anything. So why would you ever come across properties with non-standard names? You'd never write them yourself, right? Well in JavaScript, we often work with generated data that has been transformed into JavaScripts and a JavaScript object from somewhere else. And these generators of that data do not always conform to JavaScript specifications, but thanks to bracket notation, JavaScript allows us to parse data even when it doesn't follow the rules. So for example, so if I have a property that breaks convention, let's say I have a property that has a hyphen in it, I can access that property using bracket notation, and nothing will break. So, in most cases, use dot notation because it's easy to understand. If you need to pass a variable into the property name, or you need to access a property that is somehow breaking convention, use bracket notation.

### Practice: Build a new object
 
- Throughout this course, I've created rest areas for you to get hands on practice and immediately engage with and apply what you've learned. Really, go ahead and pause this video to complete these practice assignments. These are not challenges or assessments. There are opportunities for you to play around with your new found knowledge and see what you can do. You'll find the exercise files for all the practices under the practice folder. This is your first practice assignment. Based on what you've learned so far, I want you to take some objects from your life, anything within reach really, and turn them into JavaScript objects. Give each object an identifiable name, create properties that describe the objects and set their values. Maybe find a box or bag or some other object that has another object inside and create a nested object. And finally test your objects in the browser console by accessing the entire object and its specific properties. The purpose of this practice assignment is to get you comfortable with creating objects and accessing them through the browser console. So like I said, go ahead and pause this video to complete this practice assignment. Take as long as you want with it and create enough JavaScript objects that you feel comfortable with the syntax and the flow.

### Prototype Inheritence
```js
Consider this simplified version of the backpack object:

const backpack = { 

  name: "Everyday Backpack", 

  volume: 30, 

}; 
```
How does JavaScript know how to turn this code into an object? By using a template, every object in JavaScript is based on a prototype object, a template built into JavaScript itself. That prototype becomes part of every object you make, and you can find it as a hidden property called [[Prototype]]. Inspect the object in the console and you can inspect the prototype:

Screenshot of browser console showing the hidden [[Prototype]] property expanded to the first level.

For an object literal like this ("object literal" meaning it's created with curly braces {} rather than using an object constructor which is covered later in the course), the prototype can be accessed using Object.prototype. This is the core prototype for all objects created with object literals or the Object() constructor and it's the first link of the prototype chain (unless you explicitly set another prototype).

This is what's referred to as "prototype inheritance" in JavaScript. Every object you work with inherits its structure from another prototype object, all the way up to the core Object.prototype. This means every object you work with inherits the built-in properties and methods of its prototypes!

So even though the simplified `backpack` object above only has two properties - name and volume - it also has access to all the methods and properties of Object.prototype. Two of these methods are valueOf() and toString(). Here's an example of what they do:
```js
// Return the primitive value of an object property.
console.log(backpack.volume.valueOf()); // 30

// Return a string representation of the object property.
console.log(backpack.volume.toString()); // "30"
```
These and other methods are available to every object in JavaScript because all objects inherit the methods of the Object.prototype object. Furthermore, as you start making your own object constructors, you can add new properties and methods for their children to inherit. You can even override the inherited properties and methods like this:
```js
const backpack = {
  name: "Everyday Backpack",
  volume: 30,
  toString: function () {
    return `Backpack: ${this.name}, Volume: ${this.volume} liters`;
  },
};
```
console.log(backpack.toString()); // "Backpack: Everyday Backpack, Volume: 30 liters"
As we move through the course, inspect your objects in the console to see the prototype chain. You'll notice objects built from constructors have a prototype chain that includes the constructor as the first prototype, then the constructor's prototype object, and so on. This way you create a chain of objects that inherit from each other, building an expanding list of available properties and methods.

### Object methods
 
- [Instructor] In addition to properties, objects can contain their own functions. These functions typically perform actions on the properties of the object. And when a function is inside an object, it is called a method. So when you hear me talk about methods, I'm referring to functions sitting inside objects. Each method is added to the object as a property. You can see here, we have a bunch of properties: Name, volume, color, and so on. And then we have two properties towards the bottom, toggle lid and new strap length that contain functions. So these are methods. There are actually two syntaxes for these methods. The one you see here is a function expression meaning we are explicitly saying inside toggle lid, there's a function that has these parameters and this is the function body. We can also do a shorthand for this by taking the function expression away and just saying toggle lid, parentheses, and then the parameters. It works pretty much the same way, but this shorthand is somewhat harder to read. So the convention is to use a function expression. So it says function, it's very clear of what's going on. Now, let's look at how one of these methods work. So we have this toggle lid method. Inside the toggle lid method sits a function that receives one parameter. A parameter is a piece of data we can pass to the function. That parameter is then used inside the function to set the new value for the lid open properties. So we're saying this... So this current objects, lid open property using dot notation, set the value of that equal to whatever sits inside lid status, which is passed as parameter. Now we haven't covered functions yet so here's a quick crash course. And by the way, you can also skip ahead to the chapter on functions if you want to go more in depth right away, but it's not necessary. We'll get to functions at a logical point in the progression of this course. A function like you see here is a program that does something, typically change a value somewhere. Its most basic form is a function expression like the one you see here where we say function, meaning it's a function. Then we use parentheses to capture any parameters passed to the function. These are the values the function can use. And then we wrap curly brackets around the statements of the function, so what the function does. Function, parameter, curly brackets around the statements and that sits here. To make a function run, we call it by stating its name and then adding two parentheses behind it. This tells JavaScript this is a function and I want to run it. It's called a function call. If we want to pass values to the function, we put those values inside the parentheses and they become the parameters of the function. Let me show you how this works. We can do it first in the browser so we'll try to use this toggle lid function to change the lid open value. First, I'll log out the lid open values. I'll say backpack lid open, and you can see the value currently is false. Then we'll use the toggle lid method. So I'll say backpack. And because it is a property, I can just call it using dot notation so I'll say toggle lid. Now the toggle lid method is a method, meaning we need to tell the browser hey, we want to run this as a function so I'll put parentheses around it. Then I need to pass the value. Remember inside this function, we are grabbing a parameter and then we're using that value to reset the value here. So I want to set the value to true since this is a Boolean value. Hit return and we get this undefined because the function itself is not returning anything to the browser. However, something changed in the backpack lid open. So if I arrow key up twice, I get to the call for backpack lid open and you see the value is now true. Now important, I didn't change the value in script.JS. This value only changed inside the browser and that's kind of the point of having these methods. We can now pass an object to the browser and then change its properties at will using the methods and those changes only happen in the user's computer in the user's browser at that moment. We can also access these methods and use them inside our script. And down here, we have the new strap length method as well. This one has two parameters, length left and length right because we are changing both of these properties up here. So to access this, we first need to see that this actually happens. So let me console log out the value of the strap length left before then run the method and then console log it out again after to see that the change happens. So let's say console log left, left before, and then we grab backpack.straplength.left. Then we used a new strap length method. So I'll call it by saying backpack.newstraplength. And here I need to pass in two values, one for left and one for right, so I'll say 10 comma 15. And then I'll just copy this line at the top here and paste it in and then say left after. So you remember how the browser reads JavaScript from the top to the bottom? What will happen here is the browser will read down and go, blah, blah, blah, blah, blah. Oh okay, you want the console log outs, the backpack strap length left, here's the value. Then it encounters backpack's new strap length and says oh, you want to run this method? Cool, I'll run the method. The method will then change the values up here. Strap length left and right to 10 and 15 because of this function. It grabs the two values, passes them in, reassigns these values. Then we go down and say console log again. Same value, backpack strap length left. We have now changed those values so we get a different output. Save this, run it in the browser and you see now we have left before 26 and left after 10. This in a very simplified form is how methods work where you define them inside the object, and we call them using dot notation, pass parameters to them and changes happen accordingly and we can then stack the order of when we want to do things to get the output we want.

### Practice: Build a new method
 
- Before we go any further, I want you to practice building methods. Now, as I've already pointed out we haven't covered functions yet so you may feel like you're in deep water here. So let me narrow this practice assignment down for you. In the practice files, there's an object with a bunch a different properties. Some of them are strings, some are numbers, some are Booleans. To practice creating and using methods, I want you to create new methods in this object, one to change each property. The important things to remember here are, one, we pass values to a function by placing them inside the parentheses. Two, from within an object method we refer to the current object as this. Number three, any property can hold any value. So once you can access a property from within a method you can set that property to any value you like.

### Classes: Object blueprints
 
- Now we get to the really interesting part of objects. Creating objects blueprints or templates using classes. Side notes, classes are relatively new introduction to JavaScript but they've been around in other programming languages for a long time. So if you have previous experience with classes in other languages, this will all look very familiar to you. Okay, say you have a series of objects and you want to make quick work of setting them up. Verbosely declaring each object the way we've done so far would produce a lot of code and a lot of repetition since each property and method would have to be defined for each new object. A better solution is to build some sort of template. And for that, we have classes. Classes work as templates for an object type. And anytime we create a new object based on a class, that object automatically gets all the properties and the methods from that class. That means we can change the properties of the class or the methods of the class. And those changes apply to every single instance of that class that we've created. In the exercise files for this movie, I've made some significant changes. There's a new file called backpack.js that exports a new backpack class. You can see the class here, it's called backpack. And at the very bottom, it says export default backpack. Inside script.js, we are importing that backpack class from backpack.js. And then we use it to create a new backpack object here. And output the values of that object in the browser just like we have before. Finally, in index.html, I'm importing both of these JavaScript files, backpack.js and script.js and setting them up as modules. So remember from the beginning of the course that we talked about using modules to have files depend on each other, that's what we're doing here. And we can do it because a class is something that is only used internally in the JavaScript. We don't need to gain access to the class from the browser through the console or anywhere else. So class is a perfect candidate for using modules. Let's see how all this fits together. To create a class, we start with the class keyword followed by a capitalized name. This is a naming convention to ensure we know we're now looking at a class instead of just a regular object. There are actually two ways of declaring a class. You can either do this, what you see here. Which is called a class declaration. Class followed by a name. Or you can set up a class expression where you create a constant with a name again, capitalized and then you set it equal to class. And then the curly brackets. These two are just two different ways of doing the same thing. And the choice between a declaration and an expression is mainly one of preference. The trend currently seems to be, to use an expression but there's no reason to use an expression over a declaration. They are the same thing. Inside the class, we use a constructor method to literally construct the object created from that class. The constructor method first defines the parameters for each of the properties that's done inside the parentheses here. So you see here's a list of all our properties. Then inside the curly brackets, it defines all the properties and set their values to the parameters have been passed in from the class. This constructor is a method inside the class and it uses these parameters to populate these properties down here. Everything here works the same way as what we've seen before. And we use this keyword to point to the current object. Then we use dot notation to go to the property in question and set the property value equal to whatever P value was passed in through the parameters. We can also add methods to classes. So they are applied to all objects created from that class. To do so, we add the methods after the constructor method. So this curly bracket here wraps around the constructor method. After that curly bracket, we then declare the toggle lid method and the new strap length method. These methods will then be appended to the object we've created once we use the class to create an object. Now that we have a class in place, we can use it to create those new objects and that's done the following way. First, we create a new variable. In this case, a constant called everyday pack. Then we fill it or set it equal to a new backpack. So this is how we use a class to create a new object. We say the word new, this is a keyword. And then we point out whatever constructor we want to use. In this case, the backpack class. And then we just pass in the values for each of those properties as parameters. So here we have the name, the volume, the color, the number of pockets, the length of the straps. And finally, the lid opens status. And these match up to these properties. Name, volume color, pocket number, strap length, and lid open. This piece of code here creates a new object for us. And that object becomes available just like the object we've worked with so far. That means we can now console log out the everyday pack object entirely. Or we can go in and get the everyday pack pocket number properties specifically from this object. So if I take this and run it in my browser, you'll see here we have the everyday pack objects. This is a full object again. Only this time it tells me this was generated from the backpack class. You can see it says backpack at the top. And then down here, we have the pocket number value. 15 from that object. To create new objects, all you have to do now is just create a new constant with a new name and then say new backpack and pass in the values and you'll create a whole new backpack. So now you can generate many different objects without having to verbosely declare those objects in your main file. One thing to note here is you can only use a class after it has been declared. Remember, JavaScript reads from the top down. You have to make sure the class is declared before you start using it. A good way of avoiding this problem altogether is to place your classes in a separate file and importing them because all imports need to happen at the top of the main file where it's being used. So that way, we know the backpack class has been declared before we use it because the import happens at the very top. Using a class to create an object template allows us to define the property and methods structure for all the objects created with that class without having to redeclare them over and over. And if a property or method needs to be changed, you can change it in the class. And then all of the ancestors. So all the objects that have been created from that class will also update automatically.

### Object constructors
 
- [Instructor] While classes are the preferred tool for creating object templates, there is another shorter and less advanced way of doing the same thing, which relies on a basic function. It's called an object constructor function and you can see an example of it in the exercise files for this movie. Just like with the class, the object constructor uses a capitalized name to let us know this is a constructor function that produces new objects. The object constructor function captures the properties of the new object using its parameters and then defines and assigns values for each property and method using the this keyword and dot notation. So here we have this name and it's populated with the value from the name parameter that's passed to the function. You'll notice that the difference between the class and the object constructor function here is the methods live inside the main construction function, just like the properties do. So here we're assigning a new property, toggleLid and then setting up a function inside. Whereas in the class the definition of these methods happens outside the main constructor function. To create a new object from this constructor, we do the same thing we did with the class. We set up a new variable, give the variable a name, set it equal to or assign a value to it. and that new value is new Backpack. So a new object based on this constructor function. Then we just pass in the values to match the list of properties up here and out comes a full object. The end result is exactly the same as with the class but there are some significant differences. The class allows us to do more things. We can extend classes. We can add new features to them that are not available inside an object constructor function. And the class is now the preferred tool for creating objects based on a blueprint. That said in old code and in a lot of tutorials you will come across the object constructor functions because that used to be the only way we could do this and that's why I'm covering it here. My rule of thumb is use a class unless you are required to use an object constructor function because the classes give you more capabilities than the object constructor function does. And the only reason to use the older function is if you are running it in an old code base or in old infrastructure that have yet to support classes.

### Extending Classes
One of the powerful features of classes is they can be extended. You can create a new class based on an existing class, and this new class will not only inherit all the properties and methods of the existing class, but you can add new properties and methods to the new class.

This is useful when you have a class that works for most situations, but there are some cases where you need to add new features. Instead of starting from scratch and creating an entirely new class, you can extend the existing class and add the new features. A classic example of this is making a main class called MotorVehicle with properties and methods that are common to all motor vehicles, then extending this class with more specific classes like Car, Truck, and Motorcycle.

Earlier in the course you worked with the Backpack class which has properties and methods that apply to all backpacks. But there's a snag: In my closet I have a hiking backpack with an extra feature that isn't covered by the Backpack classâ€”a hydration pack. For my dataset to be complete, I need the ability to track the hydration capacity of my pack, for obvious reasons. The bigger the hydration capacity, the heavier the pack can potentially get at the start of a hike.

To solve this problem, let's create a new class called HikingBackpack by extending the Backpack class.

Here's the original Backpack class for reference:
```js
class Backpack {
  constructor(
    // Defines parameters:
    name,
    volume,
    color,
    pocketNum,
    strapLengthL,
    strapLengthR,
    lidOpen
  ) {
    // Define properties:
    this.name = name;
    this.volume = volume;
    this.color = color;
    this.pocketNum = pocketNum;
    this.strapLength = {
      left: strapLengthL,
      right: strapLengthR,
    };
    this.lidOpen = lidOpen;
  }
  // Add methods like normal functions:
  toggleLid(lidStatus) {
    this.lidOpen = lidStatus;
  }
  newStrapLength(lengthLeft, lengthRight) {
    this.strapLength.left = lengthLeft;
    this.strapLength.right = lengthRight;
  }
}
```
To create a new class from an existing one, use the extends keyword followed by the name of the class you want to extend:
```js
class HikingBackpack extends Backpack {}
```
Next, define all the properties the class needs in the constructor. This includes both the existing properties from the parent class and any new properties you want to add:
```js
class HikingBackpack extends Backpack {
  constructor(
    name,
    volume,
    color,
    pocketNum,
    strapLengthL,
    strapLengthR,
    lidOpen,
    hydrationCapacity
  ) {
    // Initialize the parent class properties
    super(name, volume, color, pocketNum, strapLengthL, strapLengthR, lidOpen);
    // New property specific to HikingBackpack
    this.hydrationCapacity = hydrationCapacity; // Capacity in liters
  }
}
```
In the above example, you see hydrationCapacity has been added in the constructor. This is the new property specific to the HikingBackpack class. The super() method is used to call the constructor of the parent class and pass in the properties common to both classes. Finally, the new hydrationCapacity property is added.

The new HikingBackpack class can also be extended with new methods. That's done the same way as before:
```js
// Method to check the hydration level.
  checkHydration() {
    if (this.hydrationCapacity > 0) {
      console.log(`You have ${this.hydrationCapacity} liters of water left.`);
    } else {
      console.log("Time to refill your water!");
    }
  }
  ```
You can also override methods from the parent class by defining a new method with the same name, calling in the parent method with the super keyword, and then adding new functionality:

```js
toggleLid(lidStatus) {
    super.toggleLid(lidStatus); // Call the parent method
    if (lidStatus) {
      console.log("Your hiking backpack lid is open. Remember to check to make sure the hydration pack is inserted.");
    } else {
      console.log("Your hiking backpack lid is closed. Remember to check to make sure the hydration pack is inserted.");
    }
  }
  ```
Here's the full code for the extended HikingBackpack class:
```js
class HikingBackpack extends Backpack {
  constructor(
    name,
    volume,
    color,
    pocketNum,
    strapLengthL,
    strapLengthR,
    lidOpen,
    hydrationCapacity
  ) {
    // Initialize the parent class properties
    super(name, volume, color, pocketNum, strapLengthL, strapLengthR, lidOpen);
    // New property specific to HikingBackpack
    this.hydrationCapacity = hydrationCapacity; // Capacity in liters
  }

  // Method to check the hydration level and alert if it needs refilling
  checkHydration() {
    if (this.hydrationCapacity > 0) {
      console.log(`You have ${this.hydrationCapacity} liters of water left.`);
    } else {
      console.log("Time to refill your water!");
    }
  }

  // Extend or override methods from the parent class if necessary
  // For example, adding extra functionality when the lid is toggled
  toggleLid(lidStatus) {
    super.toggleLid(lidStatus); // Call the parent method
    if (lidStatus) {
      console.log(
        "Your hiking backpack lid is open. Remember to check to make sure the hydration pack is inserted."
      );
    } else {
      console.log(
        "Your hiking backpack lid is closed. Remember to check to make sure the hydration pack is inserted."
      );
    }
  }
}
```

### Practice: Build a new object with a constructor
 
- Classes feature heavily in modern JavaScript frameworks and getting comfortable with writing and using them will be a huge asset to you as you started working with advanced JavaScript sites and applications. To help you solidify your understanding of classes right away here's a practice assignment for you. In the practice files you'll find the backpack class we've been working with so far. Using this class as a reference, I want you to create new classes based on one or more of the objects you created in the previous practice sessions. I recommend creating separate files for each class and importing them as modules so you have a clear separation of concerns. The easiest approach to building a new class is to start with a fully built out object and then migrate the properties and methods over one by one. Then once the class is complete, you can test it by recreating the original object using that class. Build several classes and objects based on those classes. Make sure each class has several properties and at least one method interacting with those properties and test the objects created from the classes in the browser console to make sure everything is working properly.

### Global objects
 
- [Instructor] In addition to the objects you build yourself, either directly or through a class or a constructor, the browser has a long list of default objects you can use for a variety of different purposes. A full list of all of these global objects it's available and extensively documented in the MDN Web Docs. These global objects work exactly like the object we've seen so far except, we don't need to define them, they're just available through the browser, and for the most part we interact with them through their methods. Let me give you an example of how these global objects are used, with the help of the date object that you see here. I want to extend my Backpack class an object type with a new property called dateAcquired, so I know when I got the backpack, and I can do some math to figure out how old that backpack is. Adding the new property is straightforward now that we know how the object and the class works. We first add a new parameter to the class constructor, then we set up a new property, this.dateAcquired and populated with that parameter with the value, and then finally we go through the script and just add in the new value, and here you see I'm passing human readable string, so this is not a number this is just texts that I'm passing into that value. Now that we've added the property we can output it in the browser using the same method we've been using so far, so down here I'm console logging out Date acquired, everydayPackpack.dateAcquired so that is the property in question. If I go back to my browser, you'll see down here we have the Date acquired, and this is just that string. Alright now I want to convert this text string into something meaningful, so that I can compare that date with the current date and figure out how many days have gone between them, and figuring out the age of my backpack. To do that, I'll seek the help of the date object. The date object can take pretty much any string that describes a date and time and convert it into something meaningful. What it does is it converts it into the milliseconds that have passed since the 1st of January, 1970 UTC, and then it applies methods on top of that to convert that huge number of milliseconds into something meaningful for us humans, that's done using one of the myriad of instant methods that come with the date object, and as you can see you can do so much with a date object you can take any time or any date and turn it into milliseconds, or minutes, or months, or the current date, or just a year there's a ton of stuff we can do here, let me just give you a brief preview of this, if we go into the console and I say I wonder what date and time it is right now where I am. I can set up a new constant, call it rightNow, and set it equal to new Date. Now you'll notice I am using a constructor here, just like we've done in the previous movies, only this time using a constructor that already exists in the browser. Now I can output rightNow, and what I get is the current date and time, so October six, 2020 at 2:30, in the Pacific Daylight Time Zone, and it's Tuesday. Cool, but I want to convert this into a shorter string I don't need all of that information, for that I can use a method, so in this case am going to use a method called toDateString, so if I search here toDate, you'll see here, Date prototype toDateString, returns the date portion of the date as a human readable string, Thursday April 12, 2018. Cool I want to use this, now just looking at this example I can see this as an object prototype so that's what we've been creating and then we used a method on it, so let's try to see if I can do exactly that I'll say rightNow.toDateString yes and I want to run this as a function so I add the parentheses at the end, and then we get Tuesday October six, 2020. Okay so the method works on the date object, that means I can now use the date object to do some pretty magical things I can take any date and convert it to anything else, which is exactly what I want to do. If we scroll a little further down in the Backpack class, you'll see I've added a new method here, it's called backpackAge, this new method use of the date object and a couple of different ways to do the math we need to figure out how many days it spans since I first got the backpack. So first I set up a new let so a let is just a different type of variable, I set a new let called now and set it to a new Date, so that's what we just did in the browser, that gives us the current date and time right now. Then I set up another let called acquired, and here I use new Date again, only this time I'm passing in the dateAcquired string, so I'm taking the string in the property and putting it inside the new Date, what will happen now is the date object will give me that same output except the output will be for the date passed to it that string of texts, which in our case is December 5th, 2018 at three o'clock PST. Now I have two new objects and these are milliseconds, and these represent the milliseconds since, the 1st of January, 1970 UTC for these two different dates, the current date and the date originally acquired the back. These are now just single large numbers and I can do regular math on them so in the let elapsed, I say take the now Date and subtract the acquired date so that gives me the elapsed time in milliseconds. Then finally I set up one last let, called daysSinceAcquired, here I used a math floor method to do some math on it to just take away all the decimals. And I say take elapsed value which are all those milliseconds, and then first divided it by 1000 to turn it into seconds, then divided by 3,600 to turn it into hours, and then divided by 24 which is the number of hours in a day, so this will return to us the number of days since I first got this backpack, alright? Then I return the days since acquired values, so that would be the number of days, to wherever the backpackAge method was called. Then I need to use that method and I do that just like I've used every other method so far, console.log, Days since acquired, I called everydayPack object, and then I called for this new method called backpackAge. I've wanted to run it as a method so I'll put parentheses at the end, save this, go back in the browser, and now I get this up, Days since acquired 670, so I've taken a string of text, use the date object to turn it into a meaningful date, then done some math on that date to figure out how many days ago that was, and return that back so that I can see it in the browser. This is a simple example of how powerful these built-in objects are, and like I said, there are a ton of these objects and they do a ton of different things. So whenever you want to do something, and you think it's something maybe other people also want to do there's a good chance, there's an object for it in the standard built-in objects that you can use to do math, to convert dates into other types of dates, and do a whole bunch of other things. So take your time and read through this document, to figure out what's available, and what you can use it for.
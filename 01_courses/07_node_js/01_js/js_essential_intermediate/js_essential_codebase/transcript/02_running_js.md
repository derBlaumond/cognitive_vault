### JavaScript in an HTML document
 
- [Narrator] Let's start at the very beginning with the question, where does the JavaScript live? Where do you actually write the JavaScript code? There are several different approaches to storing and serving JavaScript in an HTML document most prominently inline meaning the JavaScript itself is literally in line inside the document and as an external file. In exercise files for this movie 02_01 you'll find index dot HTML and this is an entirely self-contained HTML document that has both styles and JavaScript inline. You can see the styles at the very top here there's a style tag and then some style declarations and then an end style tag. Then if we scroll all the way to the bottom of the document right before the end body tag, we have a script tag with some JavaScript inside and then an end script tag. This script tag is how you add JavaScript to a document. Anything inside the script tag will automatically be interpreted by the browser as JavaScript and rendered as such and the script tag can actually be placed anywhere within the document. Now, technically speaking, you would want to place it in the head section because it's a meta part of the document it's not part of the actual document but in many cases, you'll find examples, tutorials even applications that place the script tag at the very end of the document. There's a good reason for this and it has to do with how the browser renders content in general, when you give the browser an HTML documents the browser just starts to read it from the top, line by line. It renders it out as it reads it and then anytime it encounters JavaScript everything stops that's because the JavaScript may make changes to the document. So when the browser encounters a script tag, it says, "Stop all rendering, I need to see what's going on here." And then reads all the JavaScript, renders the JavaScript and then goes back to rendering the entire page. That's important because if the JavaScript is trying to do something to something else that's being rendered in the page, it has to be called after the thing has been rendered and in the example here, that's exactly what's happening. This piece of code looks for any instance of the code element and you can see there's some code elements in the HTML here, but if we're going to have the browser find the code elements the browser has to have rendered the code elements first and that means the JavaScript needs to appear after the code elements, which is why the script tag is at the bottom of the document. Having settled this, what you're seeing here is an anti-pattern. This is how we used to do things and this is what you'll see in a lot of tutorials, a lot of code examples and even a lot of documentation. However, today we have better tools and better ways of loading JavaScript and controlling what happens. So in a couple of movies, we'll cover JavaScript loading the modern way in more detail but for now know that the script tag wraps around any JavaScript and you can place that script tag in the head section, inside the body, outside the body basically anywhere within the HTML element and it'll all work.

### JavaScript as an external file
 
- [Instructor] Writing JavaScript in line in an HTML document like this is a bit of an edge case, and it only really makes sense when you have just a little bit of JavaScript, and it only applies to the current document and nowhere else. In most cases, when you write JavaScript, you'll have a lot of script and you want to apply it to several different documents. In those circumstances, the best practice is to take the script, place it in its own file or several different files, and then just reference the files whenever you want to use them. There's already a model for this in how we handle CSS. If you have just a few lines of CSS and you want to apply it to just one document, it's fine to place it inside the document using the style tag, but in most cases, you want to place your styles in a separate style sheet and then call the style sheet in when you want to use it. We're going to do the exact same thing with scripts here. If you go to the exercise files for this movie, 02_02, you'll find an example. Here, we have two files, index.html, and script.js. Script.js contains all our JavaScript, and in index.html, instead of writing the JavaScript in line, we instead used a script tag to reference the external file with the source attribute. The source attribute points directly at the file. The browser will encounter this line of code and say, "Oh, there's an external file the JavaScript. "Okay, let me grab that, render it out "and then do whatever the JavaScript says "before I continue rendering." So let's test this in the browser to see what happens. Go to the exercise files for this movie, 02_02. Open it in the browser, and you get this nice white page with nothing on it. That's because there's an error here. So if I go to inspect my code, you'll see down in the console, it says Uncaught TypeError Cannot read property appendChild of null. All right. So if I go to my script here and look, I'll see down here at the very bottom, it says appendChild. So that's the function the console is saying there's something wrong with, and if I look at what the function is appended to, I can see what's wrong. So it says grab the document. Then find the body element inside the document and then appendChild. The problem is in the HTML document, the script is run before the body element is created. So this is what I was talking about in the previous movie. The browser renders everything from the top to the bottom, so it'll render out the JavaScript before it gets to the actual content of the page. The error is telling me the script can't get access to the body element because the body element was never created. To fix this, I can then take the script tag entirely and paste it in below the body element. Save index.html, jump back in the browser. It's already been reloaded by the live server, and now we can see everything is working. There are no errors in the console, and the content is displaying as it should. So the JavaScript in the external file is interacting with the real document, and everything is loading in the order it's supposed to.

### Modern JavaScript loading
 
- [Narrator] When you open an HTML document in the browser, the browser will read that document, line by line from the top down and fetch and execute any elements, it encounters as necessary. In a typical header for an HTML document, we may have references to external style sheets, and two JavaScript files. And both of these are needed for the page to render properly. So as the browser encounters these, it'll stop what it's doing, go to get the external file, then execute whatever's in that file, and then continue the rendering. When it comes to JavaScript, this can cause some significant issues. For example, we've already seen this rendering problem, where the JavaScript is referenced, and run in the browser, before the elements it's acting upon have been rendered, and therefore, we get an error in the browser. It can't do what the JavaScript is trying to do, because the elements don't yet exist. The traditional solution to this problem is to simply move, the script tag to the end of the document, so the browser only encounters it, when it's rendered everything else. This is not a solution though, this is a hack, and it introduces a whole range of other problems, there's a good chance you have JavaScript that should run at the beginning, or should happen, while the document is being loaded. And doing it this way, would mean you have to just split up the JavaScript depending on what it's doing, and then place some of it at the top, and some on the bottom. It's a really imprecise and hacky way of doing it, and it doesn't really work all that well. For this reason, we now have new tools in JavaScript to tightly control how, and when JavaScript is loaded. These tools are the async and defer keywords, and they need a bit of an explanation. So this is the default behavior. If you just reference a script and point to the file, this is what happens, the browser will start parsing the HTML document, up until the point where it finds this reference, then it stops parsing the HTML, goes and downloads the JavaScript file, then executes whatever's in the JavaScript file, and then picks up the HTML parsing. This is called content or render blocking, because it quite literally, blocks the rendering of the content in the page. And it can cause all sorts of weird problems, like what you saw in my example, and it also causes the page to just load slower, and it's not a great solution. The async keyword changes this behavior significantly. It tells the browser, 'Hey, when you encounter a JavaScript file, keep parsing the HTML while you download the JavaScript file, and only stop the parsing when you actually have the file, then execute whatever's in the JavaScript file, and then continue HTML parsing.' This dramatically shortens the time it takes for the browser to execute everything. And it doesn't, create this huge render blocking issue. There's still a hole in the rendering, but it's much shorter. This is good for some purposes, especially when you need, to get the JavaScript to parse as quickly as possible, and you don't really care about render blocking. But in our circumstance, we need to make sure the browser, only executes the JavaScript, after the document is complete. For that we have the defer keyword. The defer keyword tells the browser, 'parse your HTML and if you encounter JavaScript, just load it alongside your HTML parsing. Then when the HTML parsing is complete, execute whatever JavaScript you have.' So this is exactly what we want for our purposes. That means, I can go back to my script, and then at the end of my script tag, just add defer, save the file, and in the browser, everything is now working properly, because we are literally deferring the execution, off the script until, everything else has been rendered. Here's your takeaway. Async and defer should be the standard way of loading JavaScript today. Only use render blocking, meaning ,either placing the script tag without the async and defer keywords, or placing the, script tag at the bottom of the document, if you have a specific reason to do so. And trust me, I've asked around and tried to figure it out myself, I have yet to find a use case, where it makes sense, to not use async and defer. Loading JavaScript in the footer, is now an anti pattern. From here on forward, JavaScript should always be loaded in the head, and then you use async or defer, to control when that JavaScript is executed on the document.

### JavaScript modules
 
- [Instructor] As you start working with JavaScript, you'll quickly notice these files tend to get really large and kind of hard to work with. You can see here, this is a fairly straightforward script that isn't too much going on but you can already see it's getting really long. And there's a lot of pieces that rely on other pieces to be in place and figuring out how everything is wired together requires a lot of scrolling up and down. To solve this problem, we now have something called JavaScript modules. JavaScript modules allow us to break pieces out of a JavaScript file and place them in a separate file and then import them back into the original file again. In the exercise files four, 02_04, you can see this in action. So here we have script.js. And at the very top of script.js it says import backpack from backpack.js. If I opened backpack.js, you'll see here we have a constant called backpack. That's what's being imported. And at the very bottom, it says export default backpack. So what's happening here is in backpack.js, we've defined a constant called backpack and exported it saying to the browser this entity called backpack, in this case an object, can be used by any other file if it's imported into that other file. Then in script.js, we import that as that entity, the object, and use it just as if it was inside this file. Now if you compare script.js from 02_03 with script.js from 02_04, you'll see the only thing I've done here is taken this constant backpack and one of its helper functions, broken them out of this file and placed them into its own file. Everything else is exactly the same because thanks to the JavaScript modules, backpack, this object because it's been imported, works as if it was sitting inside script.js. It's just sitting in a separate file. Now to get this to work in practice, you have to do one more thing. Inside index.html, you need to tell the browser, first of all there are two files now. And second of all, these two files on our modules, they may rely on each other and it's important that they're both loaded before things work properly. Interestingly, when you set the type attributes to module, both of these automatically get deferred. So they will only run after everything else has happened to ensure that the browser has all the modules available before anything gets rendered out. JavaScript modules is a fairly advanced and very new feature but there's a reason why I'm showing it to you. If you work with react or view or anything else, this is standard practice. In fact, the module thinking came from these JavaScript frameworks. And anytime you go into a JavaScript framework, you'll see this import and export all the time. So now you know exactly what it is. And you also know you can actually do this in straight up vanilla JavaScript. You don't have to have a JavaScript framework. There is one caveat to doing this though and it's an important one. So let me show you. If I go to the exercise files for the previous movie, 02_03, you'll remember that the backpack object is sitting inside the script.js file. And that means if I type in backpack here, I can get to the backpack object directly from the console. It's available to me. However, if I go to 02_04, the output is still the same. But if I try to call in backpack there is no object called backpack here. That's because the backpack object is only available in the context of script.js. It is scoped only to this file in the current state, not to the browser. So that means I've taken the backpack object out of the equation where the browser is concerned. So I can't work with it the same way I did before. This is important to keep in mind, because it tells you what type of things you should be putting in modules and what types of things you should be putting in the main file. So for example, putting an object in a module like I've done here, probably not a good idea. But later on in the course, I'll show you how putting a class, so effectively a template to create objects in a separate module, makes a lot of sense because that way you can reference it whenever you need it and it doesn't have to clutter up your code. Modules are cutting edge JavaScript. And like I said, you'll encounter them all the time in JavaScript frameworks, but they also work in vanilla JavaScript if you just set it up correctly.
### Variables: Containers for everything
 
- Being able to name things is crucial to communication. If I have a bunch of objects, like all this stuff behind me and I want to draw your attention to one of them or a group of these objects, I need to use a name to refer to them. When we name objects we are effectively creating, named containers and then putting the objects inside those containers. So here's my son's pig hand puppet. To name it, I create a container with the name piggy and then I puts the hand puppet inside. Now, anytime I use the name, piggy, I'm referring to what's inside this container. And even though there are many hand puppets that look exactly the same only this particular one in the container is the one named, piggy. This is how we organize objects in the world, in our minds. Anytime we need to name an object or a group of objects to refer to them, we create a virtual container to hold those objects. Now what that container holds is entirely up to us. It could be a single object like the pig. It could be an array of objects, like these nuts. It could be a numerical value, the number five. It could be string of texts. It could even be a grouping of already defined and named objects like these different pens. This process of creating containers and placing objects inside them is also the way JavaScript handles named objects. Anytime we need to refer to some piece of data, we first create a container called a variable and then set its contents using the equals symbol. So the variable named, piggy, is set equal to the object which is the pig hand puppet. Anytime you encounter or use a single equal symbol in JavaScript, this is what's happening. A named variable container is created and something is placed inside that container. And when I say container is created I mean that pretty literally. When you define a variable in JavaScript, you effectively carve out space in the computer memory and place something inside that space. In this chapter, we'll take an in-depth look at variables to see how they work, why there are different types of variables, what we can put inside them, what we can do with them, and how we can compare, combine and even do math with them.

### Var
 
- [Instructor] In this chapter, we'll take a step back and look at some fundamentals of JavaScript including variables, data types, and various operators. For this purpose, have created the most basic of exercise files, a blank HTML document calling in a single JavaScript file. This gives us a good playground to experiment in the console. We'll start with variables. The classic variable container in JavaScript is simply called var, and it's defined with the var statement. You assign a value to a var by giving it first a name then using the assignment symbol, the equal symbol and then adding a value to it. In the console, I can create a new var by saying var, and then give it a name, container, and then use the equal symbol to assign a value to it. So I'll assign it to value of five. Now I can call in the container at any time and when I do, I get the value. So, five. So I can say container and the browser will automatically tell me, if you do this, you get the value number five. And if I actually execute, I get five back. Now, var is mutable. Meaning you can change its value at any time and assign it a new value. So I can now grab container and set the value equal to red. And this is a string of texts. Hit return. And when I now call container back, I get the string red in it's place. Five is gone and will never reappear unless I reassign container to the number five. Var was the default for all variables for decades. So you'll come across it in tutorials and examples and in code all the time. It is also the default if we forget to say that we are creating a new variable. So look at this. If I just create a random variable and assign a name to it and assign a value to it without using the var keyword, it'll still appear as a variable but the browser will not be happy. So I'll say something equals seven and hit return. Now we have a variable called something, and if I hit return, I get a seven. Now this variable is a var, we just never declared it. And if you run this through your code editor, your code editor will tell you, hey, hey, hey, you forgot to use the var statement. So I don't really know what you're trying to do. One more thing, you can define multiple different variables at the same time using the var statement. So if you know that you're going to have several different variables, you can use a comma separated list to declare them all at the same time. Var, so if I make var x equals four, y equals five and z equals blue and hit return. I now have three variables; x, which is four. y which is five and z which is blue. Finally, I can create variables that don't have any content yet. So I can say var empty and just hit return. Now we have undefined variables. That means the variable exists but it contains nothing or it is undefined. It has nothing assigned to it. So when I call back empty now, you'll see it says undefined. That means it's there, but to use it, I need to put something inside it.

### Scope
 
- [Narrator] In the MDN web docs, VAR is defined as a globally scoped variable. That means if you first assign a value to have VAR, and then inside a function, assign it a new value, that new value inside the function takes effect in all corresponding code. Even outside the function. This can cause what's known as scope issues, which result in unintended behavior errors, and a lot of frustration, as we try to figure out, why things aren't working properly. Let me show you a practical example of how this works. In the exercise files, I've set up these two boxes, ah, the color and the text in here, is populated using JavaScript. Looking at the script, it's straightforward, We set up a VAR, with the name color, and then we populated with a color in this click case, purple. This is a CSS color, which is why it works. You can also put in a hex value, if you want it to here, and it'll work the same way. Then we use query selector, to find the left, and right boxes. And we populate the style property and the background property with the color, and also the inner HTML, with the same color value. So we can see that on the front end. All right, knowing this, I also see, if I reassign the color variable, down here, to something else, sky blue for instance, that new color will apply only to the right box. Because, JavaScript is read from the top down, right? So for the first two decorations here, we get purple, for the two second ones, we get sky blue. Save that, check it in the browser. Look, now we have two different colors. That's cool. Now we can continue, down here at the bottom. I've also set up a function and I'll uncommand it. This function, called heading color, sets the color variable to blue. Then it goes and finds the title, and sets the text color, to the value of color. So if we now save this, and go to the browser, we get a blue heading, a purple box, and a sky blue box. All right. So far everything is working properly. Now we get to the scoping issue. Watch what happens if I take this function, and place it directly after we declare color sky blue. Now, looking at this, you would think, that because we are declaring color blue, inside this function, it would only apply inside the function. But if I save this, and go to the front end, you see it actually doesn't. It also affects the right box. That's because we're using a VAR, and a VAR is globally scoped. So even though we are changing the value of the VAR, inside a function, that new assignment, applies everywhere in the document, after this instance. So, JavaScript reads from the top down, says, color is purple. Now color is sky blue. Now color is blue. And that therefore, at the bottom here we get blue. Now, interestingly, this only happens, if you have the call to the function, over this item. So if I cut this out and paste it in after, you'll see the function is only invoked, after we've already set the color of the right box. And now we get this light blue instead. This a scope issue. It becomes really hard to understand why, sometimes the color is what it's supposed to be, and other times it's not. And looking at the code here, it's not immediately obvious what's happening. This issue has been a pain in the side of JavaScript developers, since the very beginning. And the result of it is that we've had to do things like declare custom variables inside functions that only exist inside those functions, and then pass variables in and out to make everything work properly, and it's gotten really cluttered. For this reason, we now have two new types of variables, a Let, and a Scope. and they are both locally scoped variables, to avoid this problem altogether.

### Let
 
- [Instructor] The let statement defines a block-scoped local variable, meaning it's only defined within its currently-enclosed block. This allows us to safely avoid that variable scope issue we covered in the previous movie. In the exercise files for this movie, we still have the same scope problem. The right box is the same blue as the title and that's not what we want. This is the scope problem. Now I can use let to solve my scoping issue. And I do that by declaring a new variable inside the function scope using let. Save this, go back in the browser. And now we have the correct colors. Looking at this, you may be wondering, How can I do this? I'm effectively creating two variables with the same name. We have var color and then we have let color down here. The reason is we're now working inside a local scope of just this function, and inside this function, we can now declare all new variables using let and they will only exist inside that function. They also ignore the other things that are happening outside. To prove my point, we can also change the global variable here to a let and everything will still work. So now, we're effectively working with two lets: One that sits in global scope and one other one that sits in local scope and only exists in here. This example shows you how important local scope is. When we're working in local scope, we're effectively treating this function here as its own separate code base with its own variables, separate from everything else, and that makes it so powerful. Now, let's see what happens if I try to call a locally-scoped let from outside its local scope. To do that, I need to change the name of this variable here. So I'll call it titleColor. I'll change it down here too, so that everything works. And then I will console log out the titleColor value from inside its scope. So we'll say... Let's see, inside, comma and then we get the proper output. Everything still works in the browser and I can open my console and you'll see down here we now have the output inside blue. So everything is working as expected. But what happens if I now copy this and then paste it outside the function scope? Before we preview it, I want you to make a guess. What happens when we try to call a locally-scoped variable outside its scope? Save it, go back in the browser. And two things happen. First of all, the box up here on the right-hand side is now green. That's the default color that was supplied before JavaScript intervened. Secondly, in the console, it tells us: Uncaught ReferenceError: titleColor is not defined at script.js line 21. Script.js line 21 is what we just inserted. So that means titleColor is not defined here. That's because title color is block-scoped to the heading color function and does not exist anywhere else. So when we're trying to call it outside, nothing happens. Well, that's not true. What happens is JavaScript stops rendering at this point because there's an error, and that's why we're seeing the green color in the right-hand box. These two declarations down at the bottom here never take place because JavaScript stalls at this line since there's an error. This may look like a problem, but this is actually the reason why we have let and we have local scope. By using a block-scope variable, we very quickly see if we're using the variable in a place we shouldn't be using it because JavaScript crashes and gives us an error. It also gives us complete control over when a variable exists and what we can use it for, which brings up an important question: When should you use a var? And when should you use a let? Here's a good rule of thumb: For most situations, when you want to use a changeable or mutable variable, you should use a let. That includes when you want to use it in global scope, because when you declare a let in global scope, it will apply everywhere except where you re-declare it. The var is only really useful if you want a mutable variable with global scope all the time, but that situation is quite rare and is a special case. So the default is, when you want a changeable or mutable variable use a let.

### Const
 
- [Instructor] The const statement defines a block scoped constant. From a scope perspective it works the same as the let statement, but a const is a constant meaning once it's defined, you cannot assign a new value to it. Let's look at our example again to see how this works here. Here we have our example in the status it was when we left it in the previous movie. Jumping over into the code, you can see we're now using lets instead of are so that we ensure that there is block scope and everything is working properly. But we still have this redefinition of a value down here. We redefined the color value to sky blue. Now let's see what happens if I change the lets at the top here to a const. Save. Check in the browser. And once again we have that problem where the right-hand box turns green. Only this time, the title is also black. So what is going on? Looking at the console we get a new Uncaught TypeError assignment to constant variable at script.js line 11. What's happening is we're trying to reassign a value inside a constant. And because it's a constant, we can't do that. So the script stops rendering, not down here where it was stopping previously but all the way up at line 11. So that means the heading color function never runs. So by reassigning a value to a constant we are breaking our script. Now you'll notice inside VS code I'm not getting any errors here. It's not telling me I'm doing anything wrong but in the browser the browser is telling me something is wrong. At first look, this might seem annoying, especially because you get no warning in the code editor when you accidentally tried to reassign a constant but it's actually a very helpful tool when programming. Assuming you follow my rule of thumb and use a let for any changeable or mutable variable using a const for any unchangeable variable makes a lot of sense. Using a const we know there is no risk of the assigned value suddenly changing or being changed by accident. And we know if we try to assign a new value to a constant the browser will flag the error and stop rendering immediately. The end result is cleaner code and less errors. One note, when I say this when I say we can't reassign values to a const that's exactly what I mean. We can't put new stuff in the const box. That doesn't mean we can't change the status or properties or other features of what the constant holds. As we've seen earlier, you can still change the properties of an object inside a const. You can also change the entries in an array inside a const, you just can't reassign the whole constant to replace the object with another object or the array with another array or an object with an array. So the key takeaway here is for any data that should be protected from accidentally being overwritten, like an object, or an array or a function, use a const.

### Data types
 
- [Instructor] Now that we know how to declare different types of variables. The next question is what can be put inside those variables? In JavaScript, the answer is pretty much anything. JavaScript is a weekly typed language meaning you don't have to declare what type of data goes into your variables you just fill the variable with whatever data you want and then JavaScript will identify or at least try to identify that data type for you. In the exercise files for this movie you'll find almost all of the data types you can use in a variable. Here we have first a string it's defined by using quotation marks at the beginning and end wrapping around the string. Then we have an integer this is just a number without quotation marks. We also have a floating point number so that's a number with a decimal to it. The reason why it's called a floating point is you can imagine a number and then you float a points in between the numbers to indicate where the decimal starts. That's the floating point right there we have bullions that's a true or false value. There is a no value so nothing saying that this value contains nothing it's just a clarity using the word null. We have two types of undefined one is when you create a variable but don't assign anything to it it automatically becomes undefined or if you want to you can actively assign the word undefined to a variable and that means the variable again is undefined. Then we have objects we've covered this extensively previously in the course you'll remember an object is defined by putting curly brackets around some different properties and values and finally, we have an array which we'll cover in the next chapter arrays are are likewise defined by using a square bracket at the beginning and end and then inside the array we have a comma separated list of items and these items can then be any one of the other data types. So we can have a string and a number and an object and another array whatever you want inside each of these slots in the array. Jumping over to the console, we get the outputs of all these different data types, string, integer, floating point number, bullion value, no value, unidentifying two versions of that, an object and an array. What you should take away from this is JavaScript does not care what type of data you put in a variable it just stores that data. If you want to find out what data type JavaScript has identified an assigned value to B, you can use a type of operator. So here we can say type of, so here in front of any of these values, we can say type of, save it. So here in front of any of these variables when we console log it out, we can just say type of and in the console it'll tell us what type of content this is. It'll say string in this case, because it is a string and if I go down here, let's see it'll say number because it's a number. So, integers and floating point numbers are both registered as numbers.

### Stricter Typing in JavaScript
JavaScript is a weakly typed language, meaning variables can hold values of any type without declaring what type of data they hold.

This can produce unexpected behaviours if we're not careful about the data types we use.

Consider this basic addition function:
```js
function add(a, b) {
 return a + b;
}

console.log(add(5, 10)); // Output: 15
console.log(add("5", 10)); // Output: "510"
```
Without strong typing, we can't tell the function to only accept numbers as arguments. As a result, if we accidentally pass in a string instead of a number, the function will concatenate the values together instead of adding them, and suddenly "5" + "10" becomes "510."

This stands in sharp contrast to many other languages including Java, C++, and Python which are more strongly typed. In strongly typed languages, you declare the type of a variable when you define it, and if the data type does not match the declaration, a warning or error is triggered. This can help prevent errors and bugs in code which is why strongly typed languages are often preferred for large applications.

But as I explained, JavaScript is a weakly typed language, yet many of the biggest applications in the world are built using JavaScript. Does that mean those applications are less secure?

There are several connected answers here:

First, to introduce strong typing to JavaScript applications, many developers use TypeScript, a strongly typed variant of JavaScript that adds static typing to solve this exact problem (thus the name). TypeScript is then compiled into JavaScript before being run in the browser.

Second, we can mimic stronger typing in JavaScript using some basic strategies. Let's break them down.

First, we can use the typeof operator to identify the data type of any value, and then test to see if the data type matches what is expected. You manually verify data types at runtime to ensure they match expectations.

Implementing this strategy for our add function would look like this:
```js
function add(a, b) {
 if (typeof a !== "number" || typeof b !== "number") {
   throw new TypeError("Both arguments must be numbers");
 }
 return a + b;
}
```
This approach could be expanded further to identify the type of each argument and tell the developer what data is being passed in. It can also be expanded to include more complex data types like objects or arrays.

We can expand on this approach and make it DRY by creating a generic assert function that throws an error when data does not meet a specified type. This function can then be reused any time we need type checking.

Here's what the add function would look like using an assert function:
```js
function assertType(value, type) {
 if (typeof value !== type) {
   throw new TypeError(`Expected ${type}, but got ${typeof value}`);
 }
}

function add(a, b) {
 assertType(a, "number");
 assertType(b, "number");
 return a + b;
}
```
For larger applications, this DRY approach is quicker to implement and easier to understand and maintain.

For more complex data types, we can integrate type checks directly into constructor functions or classes to ensure objects are created with valid types.

The example below shows the familiar Backpack class with type checks added to the constructor using an expanded assertType() function:
```js
function assertType(value, type, paramName) {
 if (typeof value !== type) {
   throw new TypeError(`${paramName} must be a ${type}`);
 }
}

class Backpack {
 constructor(
   name,
   volume,
   color,
   pocketNum,
   strapLengthL,
   strapLengthR,
   lidOpen
 ) {
   assertType(name, "string", "name");
   assertType(volume, "number", "volume");
   assertType(color, "string", "color");
   assertType(pocketNum, "number", "pocketNum");
   assertType(strapLengthL, "number", "strapLengthL");
   assertType(strapLengthR, "number", "strapLengthR");
   assertType(lidOpen, "boolean", "lidOpen");

   this.name = name;
   this.volume = volume;
   this.color = color;
   this.pocketNum = pocketNum;
   this.strapLength = {
     left: strapLengthL,
     right: strapLengthR,
   };
   this.lidOpen = lidOpen;
 }

 toggleLid(lidStatus) {
   assertType(lidStatus, "boolean", "lidStatus");
   this.lidOpen = lidStatus;
 }

 newStrapLength(lengthLeft, lengthRight) {
   assertType(lengthLeft, "number", "lengthLeft");
   assertType(lengthRight, "number", "lengthRight");
   this.strapLength.left = lengthLeft;
   this.strapLength.right = lengthRight;
 }
}
```

This last example hints at why type checking is so important. When we start working with larger functions and complex data—especially if that data comes from an outside source like an API—it is vital to ensure the data going into different functionality is the type we expect it to be.

The techniques showcased here give you more control over data types in your code, and for many applications they will be sufficient. However, if you find yourself writing a lot of type checking code, it might be time to switch your project to TypeScript. That way, you get all the goodness of JavaScript with strong typing built right in!

### Assignment vs. comparison
 
- [Instructor] You've probably noticed in JavaScript, the equal symbol is not used the same way we use it in math. In JavaScript, the equal symbol means assignment. The value on the right side is assigned to the container on the left. Anytime you see a single equal symbol, it's an assignment of a value to a variable. We also use equal symbols for comparison and that's what you see down here. We have two equal symbols next to one another, And that says, we're looking to see if the value of A equals the value of B. Are they the same or not? This code example in the exercise files is a really basic example to demonstrate how these different comparisons work. What we're doing here is just assigning a value to A and B and then we're console logging out, what the values are and also the type of data that's inside, each of these variables. Why we're doing that will become apparent in the second. Then we use a basic conditional statement. We'll cover conditions later on, but for now just know we're asking if this statement here is true. A is the same as B, then console log out, match. If not, then console log out no match. Right now, the values are five and four. If we save this and go to the browser, we get the output five as a number four as a number, and there is no match. If I go and change this to five and five, save it, go back in the browser. Five is a number five is a number and we have a match. The key to all this is this comparison. The two equal symbols tell us that we are doing a loose comparison. Meaning we're saying, are the values the same? But not absolutely the same. What I mean by that is I can actually change one of these values to a string. Technically speaking, we now have a number and a string. But if I run this in the browser, you'll see even though five is a number and five is a string, we still have a match. That's because these two values look the same. I call this semiotic equivalent, because the two symbols look the same and carry the same meaning right now. However, if I were to put in this text five and save it, we would not have a match because even though the number five and the text five, both save five, they're not the same thing. So JavaScript is trying to be clever here in saying that if you're just quoting a single number, you're probably trying to pass me a real number. So I'm going to tell you that these are the same even though they're not. If you want to test for that, to make sure you actually have two numbers, and not a number and a string with a number inside it, you can do an absolute equivalence test by adding an extra equal symbol. Now we have three equal symbols. This looks for absolute equality. The value on one side, and the other side has to be identical. Exactly the same. You can see it doesn't work here. There's no match because we have a number on a string. If we put in just the number, we get a match. But if I then do something else like I'll say five and five, there's no match, because the two values are not exactly the same. What you see here is any type of comparison like this, Either with two equal symbols or three equal symbols, returns either true or false. And then we can use that output in a conditional statement to say if the statement is true, then do something. If it's not true, then do something else. We also have some other comparison tools. We have the larger than. So if we say A is larger than B. If that's true, then we should get the true statement here. I'm going to have to actually make it true. So I'll say four, now A is larger than B. We get a true statement. If we turn it the other way and say A is smaller than B, then we get a false statement. We can also use larger than or smaller than equals two. Meaning if A is either larger, than or equal to B, then it's true. Otherwise it's false. And we can do the same thing with smaller than. And finally, if we want to see if something is not equal to, we can use a bang. An exclamation point and say, if A is not equal to B or if A is not absolutely equal to B, then do something. That's effectively just reversing the statement. Instead of testing whether it's true, we're testing whether it's false.

### Math operators
 
- [Instructor] Computers are really good at computing as in doing math and in JavaScript, you'll often have to do math to convert or combine or subtract or multiply or divide values or do other things. For all of this we have standard arithmetic math operators. In the exercise files I've set up an example so we can play around with this. So you can see it here. We've set up some lets with different values. Let me just output those lets into the console so we can see what they are. And then we have this lets called results down here where we can do a math operation and the result is placed inside the result let and then we just output it. So right now we are doing an addition using the plus symbols. So we are taking the value of A plus the value of B the result is nine because it's five plus four. We can also do a subtraction by putting in a minus symbol. This gives us A minus B the result is one. If we want to do division, you put in a forward slash this becomes A divided by B that's 1.25, five divided by four. And finally, we can do multiplication by adding an asterisk. So A times B five times four equals 20. You can also do more advanced arithmetic here so we can wrap this in parenthesis and then say A times B divided by. And then we can add in a number, so we can say two. So you remember A times B five times four is 20. And if I divided that by two, we get 10. We can also pass in another value here so I can pass it in the C value, which is 3.2, run that and we get 6.25. So using these standard arithmetic operators, you can do pretty advanced math, right inside JavaScript. In addition to addition, subtraction, division and multiplication, we have some more advanced operators we can use. One is, this one, a percentage symbol this signifies a modulo or modulus, and it gives us the remainder left over when we divide the first number by the second number. So in this case, we're dividing five by four. This will give us one instance of four, and then we have one left over. So the modulus will give us one. If I then change the value here to 10, you'll see what I mean. So 10 divided by four gives us two times four which is eight. And then we have two leftover, save that and we get three. If I change it to 15, we get four by four by, four plus four plus four, which is 12. And that gives us three remainder, right? Save that and we get three. Modulus is useful when you're doing things like testing for prime value or other things. And it is something that's often used in math. We can also do exponentiation so if we have 15 and we want to say 15 to the power of four, we can use two asterisks like this star star. So A asterisk, asterisk B is A so 15 to the of power B four. Save that, and we get a huge number, 50,625. Now there's one thing that you often do in JavaScript which falls a little bit outside of normal math. And that is, you often have a number and then you want to increment it or decremented by one. So you want to add one to the number or you want to take one away from that number. Because this is so common, we have a specialized formula for it in JavaScript and it works a little bit differently. So take a look at this, if I go down into the results here, and I say, plus plus A, what do you think the result will be over here? Now A is 15, but when I save this, the output is 16 because I've taken A, and that I've incremented by one. If I add two minus symbols in front of it instead, I get 14 because I took A and then I took one away. But it gets more interesting than that because sometimes you don't want to add the number first. You want to do something with the number and then add an increment afterwards. For that we can say A plus, plus. Now, if I run this in the browser you'll see we get 15 as a result but we also added that plus plus. To see what happens, I can then console log out just A, when I save this you'll see A is now 16. So what happened is I took A then output the value 15, then I incremented it. So then the next time we use A it'll be 16 instead. So this is an easy way of incrementing or decrementing a number. And by placing the plus symbol either before or after the value, we can control how that value comes out and when the instrumentation happens. One more thing worth noting here, and I need to reset my example. Remember how I said JavaScript often interprets a single number inside a string as the number itself. Well, things get weird if you try to mix true numbers with string numbers and then use the plus symbol for addition. So if I go up here you can see right now it says 15 and 14, right? So A and B it's 15 plus 14, save it and we get 19. What happens if I put quotation marks around the four? And you'll remember if I did a comparison here from between A and B and A is a number and B as a string with just a number four, JavaScript, we'll go, sure they're the same. But, if I do this using the plus symbol, look what happens. I get the number 44. That's because the plus symbol in this context is used as a string combiner. So we are putting the number from A next to the number from B. If I put 15 as the value in A here, it will say the number we get out is one, five, four, which is confusing. What is even more confusing is this only happens for the plus symbol. So if I used a minus symbol instead, then JavaScript will still interpret B, which is a string as a number. So if I save this, we suddenly get 11 that's, 15 minus four. And so this issue around making two numbers placing next to one another only happens with the plus symbol. That means when you're doing math, using JavaScript and you are doing addition, you have to make sure you're actually operating with real numbers and not strings. Otherwise you get weird output that makes no sense From a math perspective.
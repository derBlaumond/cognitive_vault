### The real-world function
 
- Sorting objects is tricky business. First of all, you have to decide what kind of ordering system you want to use to sort the objects, and then you have to actually sort them. Looking at all the objects on the shelf behind me, I can sort them based on a number of different factors; physical size, weight, color, brand, the date I got the item, the day I used it last. This is where computer logic and human thinking diverge. As humans, we have an innate ability to quickly sort objects based on certain criteria without really thinking about what we're doing. As an example, looking briefly at all these objects behind me, you can quickly sort them by physical size in your head. But if I asked you to sort them based on a more complex factor, like the date I last used them, you need to think a bit harder and walk through some sort of sorting process, something like this. Number one, pick a random object and find its last use date. Number two, pick another random item and find its last use date. Number three, compare the second item to the first one and place the one with the most recent date first in your array. Number four, take another random item and find its last use date. Number five, compare this date to the last item in the array. If it's older than the one in the last item then place it at the end of the array. If it's newer than the last item then check it against the next item in the array. If that's older then place them in between, otherwise keep moving it up et cetera, et cetera, et cetera. This process is an algorithm, a list of steps, and if we turn this algorithm into code, we create a function. Functions in programming work the same way functions in real life do, we specify a series of steps, and based on the outcome of each of these steps, we decide what to do next. The difference between how we do this in the real world and how a computer does it in a function is in the real world we kind of fudge the steps and don't really think about what we're doing. In computer programming, we have to carefully spell out each step and think about the logical chain we create to make sure we get the result we want. Because, unlike a human, we can't tell a computer sort these items into some sort of order that makes sense. We have to explicitly explain what we mean by sort, what factors should be considered when creating an order for the items and what procedure to use to go through each of the items to get the actual sorting right. In this chapter, we'll dive deep into the world of functions and methods in JavaScript to figure out how they work and what we can do with them.

### Functions and methods
 
- [Narrator] So far in the course, we've mainly looked at data and how to handle it through objects and variables and arrays. But the main use of JavaScript is as a scripting language, meaning we use it to write programs. And that's what functions are for. A word of note here. The term function is typically used to refer to as a function that sits on itself whereas a method is a function that sits inside an object and acts on that object. They're effectively the same thing, they just appear in different contexts. Okay, a function can be created in a couple of different ways and how we create a function has an impact on how it can be used. The classic function is a function declaration and it looks like what you see here. We start with a keyword function, then we give the function a name, we pass parameters inside a parenthesis and this can either be nothing. So it can be just the parenthesis or it can have parameters. And then we have curly brackets wrapping around the function body. Inside the function body, we perform actions on the data. And then we can, if we want to return that data using the return keyword. That data gets then sent back to wherever we declared the function originally. Now, we don't have to do that, we can also have the function just output data directly. So that depends on what you want to do with the function. If we use a function declaration like this, the function is hoisted to the global scope, meaning it becomes available everywhere. So even if we declare this function inside a local scope, it'll still be available everywhere else in the script. This function is also really an advanced variable and it can be re-declared. So just like a VAR, if you create a new function and use the same name, do some math, that new function will take precedence further down in the code. So you can accidentally override an existing function if you're using function declarations. Function declarations are easy to understand even at a glance because they quite literally say, I am a function and I have a name and these are my parameters. So the clarity of intent is clear any time you're using a function declaration. And finally, function declarations are parsed in the order they appear in the code. So if you have a function B that relies on function A, you have to make sure function A is declared before function B in the code. Otherwise, when you get to function B, function A is not declared yet and the script cannot run. So the order in which these functions are declared matters for JavaScript to work properly. Another way of declaring a function is through a function expression, and that's what you see here. In a function expression, we set up a variable. In this case, a constant, we give that constant a name and then we set the value of that constant equal to an anonymous function. So this is a function that doesn't have its own name. This anonymous function, again, has parentheses and those parentheses may contain parameters. And then we have a curly bracket wrapping around the function body. So the function functions the same way as the function declaration, except it doesn't in itself have a name. Instead, we place it inside a variable and then we call the variable. This pattern of using a function expression has become the preferred way of declaring functions in JavaScript frameworks like react. And the current best practice is to place function expressions inside a const. That makes sense if you think about it because the function expression is sitting inside a variable and it will then have the same scope as that variable type. So if we're using a const, then it is locally scoped or block scoped automatically. So if you place the function in a const, it also cannot be re-declared. So you're never in danger of accidentally overriding or destroying your function. Finally, function expressions are not hoisted. They exist only in the scope they were created, and this is also facilitated by the const being used. So in a way, function expressions are a more advanced version of functions. To call and use either a function declaration or a function expression, we simply name it and add parentheses at the end. And then if there are parameters, we pass those parameters along. You can see that down here. First I'm calling the do some math function. That's the first one up here and I'm passing along my parameters, the number five and six. They then get populated as A and B, and A and B is used inside the function. Same thing below, here we call then do some math. You can see the calling of the function is exactly the same whether it's a function declaration or an expression. And again, we pass in the values. Interestingly, because we have a function expression, if we just say, do more math and save, what we get in return is the actual function instead, which looks weird but can be useful in some edge cases. So using a function expression gives you some added functionality that can be useful. One more thing, if we don't pass values to do more math, even though it's expecting it, we'll get some weird output. Here we get NAN or not a number. We can solve that by setting default values for these parameters in the function expression itself. So we can say A equals three and B equals two. So then even if we don't pass values, we get an output and it will be the default output. But if we pass in some values, five and six, then those values we're passing in take over and we get the correct output. In addition to a function declaration, a function expression and the anonymous function that sits inside here, there is one more type of function worth mentioning. It is the immediately invoked function expression. And you see it down here at the bottom. In an IIFE, we wrap an anonymous function or a name function inside parentheses. You can see here there's a starting parentheses and an end parentheses. And then we put place another set of parentheses outside. What happens now is this function is immediately invoked and run as soon as the browser encounters it. So we are running this function right away without calling it. This particular pattern is a bit of an anti-pattern because you normally want to control when a function runs, but in some cases it can be handy because you want something to happen as soon as possible. And you can see inside this function I'm actually using one of the other functions, do some math. So when I save this page now, you'll see we get an output here where we pass in values for A and B, and then we do some math and we get the output we want. And then we can change these values here and get a different output.

### A standard function
 
- [Instructor] Looking at prototypical examples of functions like this, is useful but to fully understand functions and how they operate, you really need to see them in a real life scenario. So in the exercise files for this movie, I've set up such an example, and you can see right away that there's a lot more going on here. In this example, I've reduced our previous object demo to its core features. At the top, there is a standard object named 'greenPack' with some basic properties. Then towards the bottom, we have a constant called 'main,' containing the main element of the HTML document, and we use the append method to append some content to that main element. That content is displayed using this function expression called 'addPack.' So now we can look at how the function interacts with the rest of the content. First off, this is a function expression, meaning we have set up a constant. We've given the constant a name, and then we've set its value equal to the function. Here we have an anonymous function that has a single parameter, and that parameter is used throughout the functions. You can see it says 'currentPack' here, and we are using that parameter throughout the function. And this is really important for our functions. When we have parameters, we can pass any value in, and then reuse the function over and over and over on different values. So in our circumstance, we are passing in the greenPack object. But we could in theory, pass in many different objects, and then the object's name is converted to this generic name when it's inside the function, so we can repeat the function over and over and over again. The actual functionality of the function is wrapped in the curly brackets. You can see my code editor is helping me to see where it starts and ends. And this is what's called the function body. This is where everything the function does actually happens, and this can be absolutely anything. So in our example, we are setting up a new constant using 'createElement' to create a new article, then repopulate that new article with some 'innerHTML,' and here we're using the 'currentPack' property and getting the name, the volume, the color, and the pocket number. And finally, we're returning the value back to where we called it. So right now, we are saying, main append, and then we're appending the returned value of the functions. We're calling the function, the function returns this new object that is an article, and that article has HTML, and that's what you're seeing in the browser. Interestingly, we can also populate a variable with the same value. So I can set up a new constant here, call it 'theArticle.' Set it equal to and then I'll just copy addPack(greenPack) down here. And then we can console log out 'theArticle.' Save that, go into the console. And down here, you'll see we now get the same thing returned to us. So here we have the article with all its contents. Only this time we're handling it as a variable. So using functions, you have a lot of options on how you want to handle things. You can create a function that just does something and outputs content. You can create a function that returns content, and if you do so, you can choose what you want to do with that return. You can place it in another variable or an object or an array, and then do something further with it, or you can just use it right away like we've done here to append it to an existing element or do something else. Now, functions quickly get super complex but this is the premise for all functions all the time. The function will always have a name, either the variable that holds the function or the function itself. It will always have parameters. Now the parameters may be nothing, so you may have just two parentheses with nothing inside but there will always be those parentheses. There will always be curly brackets wrapping around the function body. And some functions may return data back to where the function was called.

### The arrow function
 
- [Instructor] In modern JavaScript, it's more and more common to use arrow functions in place of regular function expressions. Arrow functions are a shorter way of writing function expressions, and they also have some special properties, we can take advantage of. The MDN web docs, have a good breakdown of a prototypical arrow function, you can see it down here. So here we have a traditional function. We declare the function and then we have some properties and then we have the curly brackets and the function body. Looking at the arrow function below you can immediately see it is different. Instead of declaring function, we just use the parenthesis and then we use this arrow, it's an equal symbol and then larger than symbol that literally looks like a big fat arrow, and it points at the curly bracket. Everything else inside the functions of the function body is exactly the same. So the arrow function refers to this declaration here, parentheses with parameters inside and then an equal symbol and the bigger than symbol. Let's see what that would look like in our code example. So right now we have a function expression where we say const, addPack, function, and then the currentPack and then the curly bracket. If I want to transform this into an arrow function, all I need to do is take away the function declaration. So we have just the parentheses. And you'll notice immediately the code editor is saying, "Hey, hey, hey, you're doing something wrong here." So if I then hover over this error, it says, arrow expected because it now says, "Oh, you're trying to make an arrow function, well you need to actually add the arrow for me." So, I'll add in the arrow, save. And now everything works exactly as it did before, except we're no longer explicitly saying, "This is a function," instead we're using this arrow function syntax. Now you'll often see arrow function syntax be simplified even more because a lot of the time we're using them when we're just passing an anonymous function that doesn't have parameters. So you'll often see this syntax here, just parentheses and then the arrow and then a curly bracket. And in some cases, if you're just passing one parameter, you can also just name the parameter itself. So I could say currentPack, and then arrow, and then this curly bracket. And this actually works the same way as if I had the parentheses around. But notice what happens if I do this and then save the file. Prettier, we'll go, "Hey, hey, hey, that's not easy to read." So I'm going to add the parentheses back for you so that people can actually understand what you're doing, because I want your code to be formatted properly. So this in a nutshell is the arrow function. So why do we have two different ways of doing the same thing? On the surface, arrow functions are just a simpler way of writing anonymous functions. And as you'll see later when we work with events, they produce a lot cleaner code. But there are some subtle differences worth knowing about. First of all, function declarations can be hoisted, meaning you can call the function before it is declared in JavaScript. Now this is improper coding practice, but it does work. Arrow functions on the other hand can only be called after they have been declared. So we are impulsing a stricter way of writing our code by using arrow functions. Second, you can't use arrow functions when declaring methods in an object. Inside an object if you have a method you need to use a proper anonymous function declaration. The arrow function simply doesn't work in that context and we'll talk a bit about scope and this later, and that will make a lot more sense. Oh, there's one more thing worth noting about arrow functions. You can reduce and simplify the arrow function syntax to the point where it becomes really hard to understand what's going on. And some developers like doing this, personally I like to keep it verbose so I can actually see, but here in the MDN web docs, you can see the examples. So we have our regular arrow function here with the parentheses, the parameter, the arrow and then the curly bracket. Then there's a reduced model down here where we just have the parameter and the arrow and it points directly as the output. So in this case, there's very little going on inside the function so we don't have the curly brackets. And then we can also take away the argument parentheses or the parentheses that go around the parameter. So we just have a, arrow, a plus 100. Looking at this there's a good chance you go, "What is happening here?" That's what happens when I see it, I'm always like, what? I don't understand this. So like I said, I like formatting it properly or verbosely so that I can clearly see what's going on. And I think that's just good coding practice. That said, you will encounter this super short formats without any parentheses, without any curly brackets, and technically this also work and technically this is also correct code, is just very, very shortened.

### Arrow functions and "this"
 
- [Instructor] We need to take a quick sidebar here and talk about the arrow function scope and the 'this' keyword. Earlier, we saw that 'this' keyword used when we created an object constructor and you may remember, this keyword can be used inside any object to refer back to the object itself. So for example, here, we have a method inside our object called 'new volume.' New volume contains a function. And inside that function, we console log out the text, this volume in the method. And then we use 'this' keyword to refer to the volume property of the current object. You can see over here that when we use the functions we call it down here, console log(greenpack, newvolume), when we use the function we get the volume in the method, which is eight. So that's what's declared up here. And then afterwards, I use this volume to re-assign a new value to this attribute. And that's the value that's passed in through the new volume method. So it gets captured up here and then assigned. And therefore the second entry says this volume after update is five. So we're passing five in to the method, five is then reassigned to the value. And we can refer back to this because this has now been changed. The important thing here is, that this keyword works fine inside a regular function inside an object. But, if I call in a function inside that function, weird things start happening. So to understand this example which admittedly is a bit convoluted, I need to explain exactly what's going on. By the way, this is convoluted because these issues only arise in convoluted circumstances. So this is really the easiest example I could come up with that fully encapsulates what's going on. Below here, I've added an immediately invoked function expression which is an anonymous function. So you can see that we're running a function inside our method. And in this function, I say this volume in nested function. And then we, again, I'll cut this volume. Now looking at this, you would say, well, we're doing this right after we re-declare the volume number, right? So we should get the same value as the one above here. But if I save this, the output we get is 20. Why, well that's because, if you look all the way at the top of the file, we've declared the window object volume to 20. Now remember, I said, if you use a function declaration that function declaration is hoisted to the global scope. So what's happening here is this function is hoisted out of the object and up to the global scope. And suddenly, this is pointing at the window object and we're getting the volume of value from the window object, which is not what we want. This is where the arrow function comes in. And this is really important. So I'll copy this and paste it in. And then instead of using a function expression, I'll use an arrow function. So I'll say parentheses and then an arrow and then save it again. Now look over here, you see that the function expression outputs 20. So it's hoisted up to the global scope. Whereas the arrow function stays within the current scope and output five. The interesting thing is this is happening because an arrow function does not have its own 'this.' It does not know what this means and it will refer to the closest available scope which in this case is the object. And that's why we're able to get a hold of it. This also explains why we can't use an arrow function as the declaration for a method, because if we did that, the arrow function wouldn't know what scope to use. So we would refer back to the global scope instead of the method scope and therefore nothing would work properly inside that arrow function. So the bottom line is, if you're using 'this' in a method within an object, and you then get an odd result, try turning the function into an arrow function to see if that solves the problem. Most likely, you're dealing with the wrong scope and an arrow function will help you get the correct scope because it doesn't carry its own scope with it. For more on this, you can read the very long and detailed article on MDN that explores 'this' and all its interesting parameters in an object. But I recommend you do that after you're finished with this course.

### Practice: Build a function
 
- Functions are an integral part of JavaScript. And as you've seen, there are several different ways of declaring a function. In this practice assignment, I want you to really familiarize yourself with the basics of how to declare functions so you get used to writing them, calling them, and making them do stuff. Function expressions, function declarations, and arrow functions, all have their uses, and being comfortable with declaring all of them and recognizing them is hugely important to your learning. So here's what I want you to do. Create a basic function declaration. You'll remember, this is where we say function followed by the name of the function. In the body of the function declaration, do something to an element in the DOM. For this, you can use any of the techniques we've covered earlier, finding an element using QuerySelector, adding a class, whatever you like. Call this function declaration so the action actually takes place and check it in the browser. Then next, create a basic function expression. That's when you define a variable and then place an anonymous function inside. Do the same as above, find an elements, make a change to it, call the function, make sure it works, and finally, create an arrow function, make it do something and call it. This practice assignment is all about making functions. What the function does is less important at this point. I want you to get familiar with getting the different types of functions to work.

### Pass data to a function with parameters
 
- [Instructor] Functions are a great tool for using or transforming data in some ways. So let's break this down further, so you can get a firm handle on how functions work. For us to be able to pass data, we need to be able to pass that data to the function in the first place. And this is done by passing arguments through function parameters. To explain, let's build a basic example, a tip calculation function. I've already built the framework for the function for you, except, this function isn't very useful right now. It calculates the tip of 18% for the value 29.95. And no matter how many times you run it, it will only ever give you these values and nothing else. What we want to be able to do, what would make this function useful to us, would be to pass a sum and a percentage number into the function and then it will return the tip and total for us for whatever values we pass in. To do that, we need to specify our values down here in the call to the function using arguments and those arguments then get captured by parameters up in the function and use inside the function. So, let's set that up. I need two parameters here, sum and percentage. Now that I've declared these values, I no longer need to specify them inside the functions. So, I'll just delete these two lines here. These two parameters now become available inside the function. So whenever I mention sum in the function body, I'm referring to the parameter value up here, which is the argument we passed in. Now I can pass in those arguments and they match up to the list I have up here. So I have sum, percentage. That means I need to put in 29.95, and then 18. And if we save this, we get the exact same result as before over here. Cool. Now I can try to change the values. So maybe 28. Let's say I want to give a really big tip. So watch over here, save. And I would say, 28 and the tip and total are completely different. Now that I see how these arguments and parameters work, I can start extending the function with more information. For example, you can see over here in the output, we don't have a currency symbol. So I want to add a currency symbol but I don't really know what currency is being used. So I want the user to be able to pass in their currency symbol. For that, I'll add a new parameter and a new argument. So, the parameter will be called currency. And then down here, if I add a comma, you'll see it now says tip calculator, sum: any, percentage: any, currency: any. And the currency is the one I'm currently working with. So here I'll pass in a string with a dollar symbol. Then, now that I have the parameter, I can use it inside my code. So here I'll just add on inside the template literal, currency and then I'll add it wherever I want it to appear. So I'll want it here, here and here. Save that. Woof, got an error. Currency off. Dyslexics, so I make mistakes like this all the time. All right. Let's just make sure it's the right one by highlighting it. Yes, yes, everything's matching. Okay, cool. Right. So now we have the denomination marked on the frontier. But what if I want to use a different currency? Let's say Norwegian kroners, which is like this. Now Norwegian kroner wants to put the KR at the end, not the beginning. So that looks weird. How do I handle that? Well, I can pass a Boolean value and then output different content depending on what that Boolean value is. So I'll set up a new parameter, call it prefix. Then I will create two outputs here. So I will say if prefix. Now this format says if prefix is true, then do this. And if prefix is true that I want to output the content as it is right now. So I'll copy this and paste it in. So that means we get the prefix in front of the other content. Let's see the currency is in front, else. So I'll go after the curly bracket and say, else that means the prefix is false. Then I'll take this stuff again cut it out this time and paste it in. And this time I'll move currency to the back of each of these values. Like that. And then I have to pass in either a true or false. So in this case, I'll say false. That should trigger the, else, condition. And here we can see the KR is set to the back If I then again, pass in a dollar symbol and set it to true instead, save, and now the dollar sign is set to the front. So as you can see, using these parameters and arguments we can pass any data we want up into the function and then the function we'll just use the data we pass to it.

### Return values from a function
 
- [Narrator] The tip calculator function executes code and outputs it directly into the console. In some cases, this is what we want a function to do, just immediately output content. In other cases, we want a function to return some content to where the function was originally called so that we can process that content further. So in this movie, we'll look at how to do that using the return keyword. If we look at the output from the tip calculator function right now, you'll notice we're using the punctuation mark to delineate the decimals in the currency. This is correct for some currencies in some languages but not for all of them. We're also not showing the correct currency symbols here or rather we can pass it in but we don't really know what they are. So we're not getting the correct output here. I want to upgrade my function to output the correct currency, formatting and symbols for whatever currency we are targeting. And to do that, we'll create a new helper function to transform these numbers for us. In the exercise files for this movie, I've reduced our example down to the bare minimum again, because we don't need to pass in a currency symbol and then say before or after, instead we're going to have an automated function do that for us. Now, remember how I said, JavaScript has a bunch of global objects that we can use to perform common functions. One of those functions is to transform a number into an internationalized number format. So we can say which language it should be and then it'll output the number in the correct formatting for that language. We're going to use this international number formatting object, and it's a constructor for objects that enable language sensitive number formatting, which is exactly what we want. In fact, the very first example here is an example of what we want to do. You pass in a number and then you get out the correct formatting for a specific currency. The first step of this process is to create a new function. I'll call it formatter. So const formatter, I'll set this equal to arrow function. And inside this arrow function, I'll set up a new let called formatted value, and then I'll return formatted value. So now when we call formatter, we'll get whatever is sitting inside the formatted value returned to us and then we can process that number further. What I want to do now is pass the values from down here up into formatter and do something with them. So I'll set up a parameter for formatter here and say value. And then down here in the function, I'll say formatter and then wrap it around the value we want to format. And I'll do the same down here for tip and for total. So what happens now is when I call tip calculator, tip calculator will then take each of these values, the sum, the tip and the total, pass them up to the formatter function then do something to those numbers and pass them back out or return them back out and display that down here. Now we need to actually do something with these values 'cause right now we're capturing the values but not using them. That's where the international number format object constructor comes in. And we're actually just going to copy out this entire code example here 'cause it's exactly what we want. That's often the case when you work with JavaScript objects. Then we'll paste that in here as we'll say let formatted value equals what I just copied. I'll save it so that it gets formatted properly. Then we get an error over here in the console and that's fine 'cause we're not done yet. Then we need to grab the value and pass it down into our new object, that's done here. So now the value that's passed up from the formatter goes up here and then gets returned back. And we do this and save, we get a new output here. And this output is formatted for Germany, the German language and the Euro. And if we then go in and change this to something else, let's say en CA, which is Canada, and then CAD which is Canadian dollar and save, we'll get a different output. So that means our object is working. However, we need to be able to pass the locale and the currency in manually. So I'm going to add in two more parameters here, locale and currency. And then say that locale is this thing here. So we'll pass in that as a variable or parameter. And then the currency is down here. Now that we have these two new parameters, we need to pass them up from where we call formatter. So I'll just paste them in here. So we're passing locale, currency and sum, locale, currency and tip, and locale, currency and total. Of course we don't have these values inside tip calculator yet, so we need to add them here as well. So we'll say, locale, currency, and then like that. So now tip calculator has some percentage locale and currency, and that means we need to pass in locale and currency down here where we're calling tip calculator as well. So we'll say the locale is DE-DE like our example and the currency is EUR four Euro. Save this and we get the correct output over here in the console again. So now we can see what happens. We call tip calculator and pass along the four arguments. The value, the percentage, the locale and the currency. These are all captured as parameters up here. The sum, percentage, locale, and currency. Then we do the regular tip percentage math. Then we go into the console log and say we want to pass some values up to the formatter. We pass the locale, the currency and the sum. So that's the locale, the currency, and the sum that was generated here up into the formatter who then uses the international number format object to create a new object using the locale, the currency and the value, and returns it back to tip calculator. And that's the value that we get output in the browser. So now we can pass any value we want here. So if we want Norwegian, NO and then NOK. And save it, you'll see the format changes again. We want US dollars. We say, EN US and USD. Save, and we get a different output. Now you see how important the return keyword is. Using the return keyword, we can pass information back and forth between different functions, and use functions again and again to do different things like in this example where we're using the formatter function three times inside the tip calculator function to get different results for different purposes. That way, we can create helper functions and we don't have to do everything inside one function.

### Return: A Deeper Dive
The return keyword in JavaScript is far more versatile than both its name and general examples suggest. So let's dive a little bit deeper and see how simply returning from a function can open up a large possibility space.

For reference, here's the standard use of return in a function:
```js
function sum(a, b) {
 let result = a + b;
 return result;
}
console.log(sum(5, 3)); // Outputs: 8
```
Here, return is doing its primary job: literally returning a value to the caller.


Early exit
Hidden by the standard example above is how return terminates the execution of any further parts of the function. This feature is crucial for controlling when complex functions run and for how long they run.

Consider this example where return is used to stop a function early:
```js
function calculateDiscount(items) {
 // Check if there is more than one item
 if (items.length <= 1) {
   console.log("Discount is only applied when there are more than one item.");
   return; // Exits the function if not more than one item
 }

 // Calculate total price of all items
 let totalPrice = items.reduce((sum, item) => sum + item.price, 0);

 // Calculate 15% discount
 let discount = totalPrice * 0.15;

 // Calculate final price after discount
 let discountedPrice = totalPrice - discount;

 // Return the discounted price
 return discountedPrice;
}

// Example usage:
const items = [
 { name: "Book", price: 20 },
 { name: "Pen", price: 5 },
];
```
const discountedPrice = calculateDiscount(items);
console.log("Discounted price: $" + discountedPrice.toFixed(2));
Here the return statement is used to exit the function early if the condition is met, preventing the rest of the function from running. For large applications, this approach is essential for speed and efficiency.


Returning functions
return doesn't just terminate a process and return a value. It can also return functions, also called higher-order functions. This is a powerful feature that can be used to create configurable functions or for currying.

Here's an example of returning a function:
```js
function createMultiplier(multiplier) {
 return function (value) {
   return value * multiplier;
 };
}

const double = createMultiplier(2);
const quintuple = createMultiplier(5);

console.log(double(5)); // Outputs: 10
console.log(quintuple(5)); // Outputs: 25
```
In this example, createMultiplier returns a function that multiplies a value by the multiplier parameter. We then use this returned function to create new functions that multiply by 2 and 5 respectively. Finally, we call these new functions with a value to see the results.

Modern JavaScript applications often rely on asynchronous operations to fetch data from servers through APIs or perform other tasks that take time. In these cases, return is used to handle the asynchronous results.
```js
async function fetchData(url) {
 let response = await fetch(url);
 let data = await response.json();
 return data; // Returns a promise that resolves to data
}
```
Here, return is used to return the data fetched from the server, and once the data is returned, we can output it to the console or use it in other parts of the application.

Inspecting code, you'll notice arrow functions often omit the return keyword altogether. This is because these functions have a special syntax that allows for implicit returns.
```js
const add = (a, b) => a + b; // Implicit return
```
This feature of arrow functions simplifies function declarations significantly when only a single expression is involved.

### Practice: Pass values between functions
 
- Passing data to and returning data from functions changes a function from a basic, single purpose tool to an entire factory for data manipulation. In this practice assignment, you'll get to play with passing data back and forth between functions to create more efficient and reusable code. This is sort of a lead-up to how we work with components in JavaScript frameworks. So getting your mind on this track here and now will help you in the future as you continue on your learning journey. Here's what I want you to do. Writing markup for images quickly becomes clunky, especially if you wrap your images in a figure tag and add a figcaption or you use responsive images markup. In the practice files, you'll find a basic html page with a main container. Using everything you've learned so far, I want you to create two functions, one dependent on the other, to output some data from a custom object. The object is already defined in the JavaScript file. And all you have to do is pull the different properties and add them wherever you think they make sense. This is a practice assignment, so be as creative or as uncreative as you like. Like I said, create two functions. The main function creates a new article element, populates it with some content from the object properties and returns that new element with its content to where the function was called. The second function is called by the main function. Its purpose is to create a new figure element populated with an image pointing to the image URI defined in the object, add a figcaption with an image description, and return that whole figure back to the main function. Finally, use querySelector and the append method to append the article with all its content, including that figure, to the main in the document. The key to all this is to pass the objects to the main function, then pass it to the figure function, return everything from the figure function into the main function, and then return everything back to where the main function was called. The goal of this practice example is for you to get familiar with the idea of breaking big tasks into smaller tasks. You see, marking up images can quickly become a big task. And once you've created a function for image markup, you can reuse that function anywhere you want to display an image by just passing in the arguments you want, which in our case would be the image URI and the description.

### Callbacks
 
- [Instructor] Sometimes we have two functions and we want to control the sequence at which they execute. This typically happens if one function relies on the output of another function for data or when one function has to wait for another function to complete before doing something. One way of handling this type of function sequencing is through what's known as a callback function and this is a traditional method for handling this type of problem and you will come across it all the time. In the exercise files for this movie I've updated our tip calculator example a little bit. So from the bottom, the tip calculator function now creates an object named final tip with all of the data. This object uses the format or function we created previously to format the number values and nothing is new here, except for that object. What is new is directly above here is this new callback function called print HTML that receives the final tip object. The idea here is I want this print HTML callback function to output an HTML table that appends to the main and the document so we can see the results of the tip calculator in the browser over here. To do that I need to make sure that things happen in the right order. So I want to pass my values into the tip calculator and only when everything is done do I want to call in the new print HTML function and then that function will output the content into the browser. This is where we'll use a callback function and call it callback. It can be called whatever you want but I'll just call it, call back cause that makes it really clear what's going on. So expand this to the full view so you can see what's going on. So callback is here then at the bottom here, I'll say call back and inside call back I'll pass final tip then inside the callback I'll pass final tips so that we're throwing the final tip object to the function in question. Now the functioning question is print HTML up here but it doesn't say print HTML anywhere so far, right? Well, what we're going to do now is pass a call to the callback from tip calculator down here. So we'll say the name of the function we want to run which in this case is print HTML, looking at this and thinking back to when we were talking about function expressions and function declarations I think you might be able to figure out what's going on. Remember how if we have a function and we call it using the parentheses then we are executing the function but if we are calling a function expression without adding those parentheses, we're actually calling the entire function and passing it forward. So what's happening here is when we call print HTML without the parentheses in the end, we grab this entire constant here with the print HTML function inside it and then we pass the entire function up into tip calculator as a value that value the function gets pat captured in this parameter callback and down here we then place that entire function inside the callback and append final tip. So that way we're effectively running print HTML inside the tip calculator function instead of sending values to it. So when I save this and go look in the browser, you see we get the output we want inside the browser. If I reduce this again you can see if we pass different values here. So we have nb-No and NOK, save and we get the updated information over here. So everything is working the same way except I'm now using a callback function. Looking at this, you may be asking an obvious question which is why can't I just call the function itself? I mean, I could just call print HTML down here right? And I would get the same output or we can try. So I'll say print HTML save, yeah, you're right we get the same output. So why on earth would I want to do this callback thing, right? Pass the entire function up in and then use it. Well, there's a simple reason. There's a good chance when you set up some more complex code that you may have different callback functions you want to use for different purposes. So in this particular circumstance we want to use the print HTML function but there could be several different versions of the print HTML function and then you want to use them for different purposes and by calling a callback like this, you can pass in exactly the function you want into the other function. So we're effectively saying here is the precise function I want you to use once you're done processing your information right now but later it could be a different function. Like I said callbacks are a traditional way of handling this and in modern code, we also have more modern tools like promises that can do something similar but you'll see this pattern all the time when you work with JavaScript where you call in a function or call back a function and then get a value. You'll also see this pattern and other types of features. For example, if you are working with a set timeout function you are in fact working with a call back function or if you're working with an event listener which is something we'll do later on in the course you're also working with a callback function. So this format of throwing a function into another function and then getting it to execute is a standard pattern you see all the time in JavaScript.

### Conditional if...else statement
 
- [Narrator] Much of programming centers around conditional logic statements. If this condition is true, then do this. If not, then do the other thing. The if else statement is the most basic and probably most used conditional statement in JavaScript and most other programming languages. So let's take a closer look at how this works 'cause you'll use it all the time. In the exercise files for this movie, I've brought back our backpack packer example. Now, if we look at it in the browser, there's one thing in this example that's really irking me and it's down here at the bottom. It says lid status: false. This makes sense if you know what it means, but it's not really the way we would communicate the lid status. We would say lid status open or closed, right? Now, the reason why it says false is because in the code we're just outputting the value of this property inside the everyday pack object. And it's a Boolean value, so it'll either be true or false. So I want to output some human readable text here instead. And for that, I'm going to use a conditional statement. Now, before we put it into the actual code, let me just show you how a conditional statement works down here. So we'll set up a new conditional statement, if. The conditional statement tests to see whether a condition is true or false, and it can be any expression that we're testing here, it just needs to return either true or false. So in our case, we want to look at everyday pack, the object, and then look at the lid open property. And we want to see if that lid open property is equal to true. If that's the case, then everything inside the curly bracket will happen. And here we can place any expression, a function, whatever we want. So in our case, we just want our console log out. Lid is open. Now, if we want to, we can also append an else statement here. This is entirely optional, but if we want to have something else happen, if the statement is not meant, then we say else. Again, curly brackets wrapping around whatever expressions happen if the condition is not met. Let me say else, console log, lid is closed. Sad face. Save that, go check out the console. And here you'll see it says lid is closed because the value is currently false. So if we go up and change the value in our object to true, and check again, it'll now say lid is open because it's now true. This is a really basic conditional statement. And it perfectly demonstrates how conditional statements work. We are testing for a condition, and then we're looking for either the condition to be true or false. Now, in this particular circumstance, because we are looking to see if everyday backpack lid open is true and it's a Boolean value, we don't actually have to say equals true. We can just simply express everyday backpack lid open because if it's true, we have everyday backpack lid open, and that will pass true. If it says false, then it will pass false and we go down to the L statement. If I save this, you can see everything is still working. This is only because we are using a Boolean statement though. If we were testing for something like a string match to see if a string matches, this would not work because any time there is a string, it would pass as true. So if, for example, I said up here, it's not true like this but it's a string that says true and save it. It's still true because there is a value sitting there. But if I took the value away and set undefined, it would be false. And if I said null, it would also be false because these aren't real values. So if I want to match a string, like true, I have to make sure I actually do a proper comparison. And in that case, I need to say equals equals equals true. That way, it'll only mark true if it is actually the same string, otherwise. So if I test for, let's say true with a capitalized T, it'll say false, right? So that's how the conditional statement works. Now, in our circumstance, because we are doing an if else statement and we want to put it into some other code, we can also use a short hand version of this called a ternary operator. The ternary operator looks like this. I'll say console log. And then first I put out the condition, in this case, everyday pack lid open. Then I say, if that is true with a question mark, then output open else using a colon, closed. So if everyday backpack lid is open, then I would put open. Otherwise I'll put closed. Save that. Now it says open. If I scroll up and change this value to false, it says closed. All right, so now we have the output we want and we need to put it into our template literal here. So I'll scroll all the way to the bottom again and just grab this, copy it, and then find the place where I have everyday pack lid open. And I'll just paste that ternary operator in. So what will happen now is, when we get to this expression here, inside the template literal, we are doing the same thing. We're saying if everyday pack pack lid is open, then output open, otherwise output closed. Save, go into the browser. Look, now it says lead status closed. And if I scroll up to the top here and change it to true and save, now it says open. So there you have it. Conditional statements working through ternary operators.

### Logical operators
 
- [Instructor] Conditional statements like this if, else statements rely on logical operators. We briefly talked about these earlier and now we can see them in action. A conditional statement is looking for a condition to either be met or not met, meaning we can use any expression that returns either true or false as the condition. In this example, I'm using the backpack age method which returns the number of days since the backpack was originally acquired and then I'm asking if the everyday backpack age is larger than or equal to 30, then we return backpack is used, otherwise we return backpack is new meaning the backpack is really under 30 days old. This is a good example of how conditional statements work. I can now change those to say, backpack age must be less than or equal to 30. Then of course I would have to change the logic here to say backpack is new at the top and then backpack is old at the bottom. If I want to test to see if backpack age is not equal to a specific number, I can just put a bang in front, say not equal to or not absolute equal to and then we will only return true if we get any value outside of 30 but if we get 30 then we'll have that set to true. Now, in addition to these comparison operators, we also have logical operators that allow us to make more complex statements. In specifics, we have And and Or. So let's say I want to test to see both whether the backpack, it has a certain volume and how many pockets it has. So if it has a large volume and a lot of pockets, then I say, it's a big pack. If it has a small volume and just a couple of pockets, then it's a small pack. In that case, I need to create an And statement. So I'll say, everyday pack and then we're looking for volume first. So I'll say floor volume is larger than let's say 15 liters and so two on percents, everyday pack again and this time we're looking for the pockets. And I say, if the pockets are larger than or equal to five. So now we're testing for both of these conditions and only if both of these conditions are met do we say backpack is big. Otherwise backpack is small. Save that and over here it says backpack is big because the volume is 30 and the number of pockets is 15. We can then test to see. So if we say volume needs to be 35 for the backpack to be big, save and then we'll say backpack is small because one of these two things do not meet. When we're using the And statements, both of these two conditions need to be met for the entire expression to return true. We also have the Or statement. It's signified with two pipes like this. Now we're saying if either the first statement or the second statement or both are true, then we return true, otherwise we return false. Now you may have noticed this does not test for either A or B, but not both. We don't actually have an expression for that. We'd have to combine some different expressions to make that work, but the logical operator Or will test for either condition A or condition B or both. So between the standard comparison operators and these two And and Or, you're able to string together whatever kind of logical expression you want to test for whatever condition you want.

### Conditional switch statement
 
- [Instructor] The if else statement is a useful tool, but in many cases it's not the right tool for the job. Let's say you want to output different values depending on how old the backpack is. So if it's under 30 days old, it's new. If it's under one year old, it's lightly used. If it's one year or older, it's used. And if it's more than three years old, it's old. We could do this by nesting conditional statements inside one another. But as you can see from the code example it gets clunky and hard to read. Here we're saying, if the age is over 30, and if the age is over 365, and if the age is over 1095, then it's old. Otherwise it's used, otherwise it's lightly used. Otherwise it's new. This is not only hard to write, it's also hard to read. Instead, when we want to get different results depending on various conditions, we can use a switch statement. Here if we look at the code example, we provide an expression which is effectively a value. And then we provide a series of case clauses expressed with case, and then the clause. And each of these case clauses describes a specific condition. The switch statements then starts at the top and goes through each of the cases, and we'll stop when it finds one that matches the expression and then output whatever content is inside that case. And then go to break, meaning it stops the switch statement from continuing. Then at the bottom, we usually have a default statement. So if none of the conditions are met, we use, we do whatever it says in the default statement. As this example on MDN shows, switches typically used for literal matching. So here we're looking for the word papayas and then when we hit the word papayas, we output the content. But we can also use this same switch expression to test for ranges or testing for different conditions by coming at the problem from a slightly different angle. Let me show you how this works. So first I'll wipe out all these if statements 'cause we don't need them anymore. This used status function sets up two lets, first age that grabs the backpack age and then also a description. And then it just outputs the age and the description down here. Those both show up in the console in the browser. Okay. So now we need to redefine the description based on age. So we'll set up a new switch statement. It's just called switch. Then we set up the expression we want to test against and here we're going to test against the expression true. Then we can use conditional statements and if the conditional statement is true then we pick that case to output the content. All the cases are put inside curly brackets and then we just name each case in turns we'll say case. First we want to see if the age is smaller than 30. That's our first condition. If that's the case, colon, we output something in this case, description is set to new, then because we've met our condition we break and that means we stop the switch statement from continuing to run. If this first case, so this condition is not met, so it's not true. Then the object is slightly older. So that means we can set up a new case. And this time we're going to use two statements. So we'll say age is bigger than or equal to 30 and two ampersands age is smaller than 365. So this will give us the condition where the age is over 30 but under 365. And only in that circumstance, will this return true. If that's the case, meaning the bag is less than a year old then the description should be lightly used, again break, another case, this time we say age is bigger than or equal to 365, and age is smaller than 1095 that's the number of days in three years, description, used break. And finally, case, age is larger than or equal to 1095. So that means older than three years old. Description equals old. Break. And then as I showed you in the example the standard is to always provide a default expression if none of these conditions are meant. So that we at least get something and even if we don't pass the right values we say console log and then I went to put in a template literal and say, there is no description for and then we put in the age. All right. Now we can save this and run the switch statement and you see over here, we are currently at 673 days which on the status is used. And looking at the logic that makes sense. We can now test this very easily by just setting age to a value. So let's start by setting it to 29, that should give us new, right? 29 days new, so we're hitting the first condition. Cool. What happens if I set it to 30, lightly used that's the second condition, right? Age is bigger than or equal to 30. So let's set it to 301, save still lightly used because it's under 365. So, 364 still lightly used 365 used. Okay. So now we're in the third condition. Then we can say, let's say, 1094, 1094. Save, still used 1095 and it's old. Okay. So our switch statement works. And as you can see we are using the switch statement with logical statements and combiners, so we're testing for two different logical statements at the same time.

### Looping through content
 
- [Instructor] JavaScript gives us several different statements and methods for repeating a process over and over or looping through arrays and nested objects. Common to all of them is we first specify under what conditions the loop or iteration should run in the statement declaration. And then we specify what should happen at each iteration in the body of the statement. Let's look at some of the most common and useful iteration statements for arrays and objects. In the exercise files for this movie I've set up an array called stuff that has some items in it and a nested object called nested objects. That is an object with a bunch of nested objects inside it named item one, two, three, and so on. Now I want to loop through each of them and display that in the browser over on the right hand side, scrolling down, all we're doing is grabbing the article in the page then creating a URL and then using different loops to populate that URL. And then finally we append the list of list items to that URL so that it displays in the page. Off the top we use a for loop to loop through the array and displayed in the browser. The for loop is the classic and default way of looping through an array and it also allows us to loop through anything else. The for-loop always contains a statement like this inside that says, we first set up a let's name I. It could be named anything but it's typically I just increment and we set it to zero. Then we say for as long as I is smaller than some specified length, then run through the loop and then iterates I. What happens now is we'll keep iterating through this content again and again and again and I will keep increasing in size until we hit stuff length. Now to get this to work with an array what we do is use I inside the statement here. So we're saying stuff I, so we're starting with item number zero. That would be the first lot in the array. Then we iterate through that once. Then I is incremented up one. So now we have item number one it's still smaller than stuff length. So then we pass it down here, use it again and we keep doing that until we hit stuff length. So if you want to iterate through an array you use stuff length, that's the length property of the array to say when the iteration should stop. This for loop allows you to repeat a process as many times as you'd like and you just specify when you want it to stop. It is for anything. It's not just for arrays but you can see when you use it for arrays, it's a little bit clunky because you have to keep passing this I value down into the body of the loop to get everything to work properly, but it works. However, in modern JavaScript we have better tools. Down here below, we have a for of a loop. In the for of a loop we specify which array we're working with and then we say for as long as we have new items in this array, keep iterating through them. So we say for, then we create a const or a let's name the item or something similar of the array you want it to work with. So for long as we have an item in the array then do this and then we can keep looping through. And here we're just working with a single item. So you see, we don't need to say stuff I anymore, we're directly working with the item and we'll keep looping through until there are no more items available in the array. If you want to be even more direct you can also use the for each method. And this is the preferred way of dealing with arrays in modern JavaScript. The for each method applies directly to an array. It grabs each of the items and then it performs an action on those items in the form of a function. So here we pass an actual function using the item as the parameter and then we can deal with the item inside that function. The difference between using a for each method and using the for of statement is in the for each method we are actively working on the item itself in functional programming. We're using a function to do something with the item instead of just naming the item and then performing some actions around it. Both the for each method and the for of statement, apply to arrays. So what about objects? Down here at the bottom, we have a for in statement. The for in statement works exactly the same as the for of statements, except we are now working with objects. We're saying, for single object, in the objectig question in this case, nested object. So we are saying for as long as nested objects has more items, take the next item put it into this constant called single object and then do something with that constant. So single object becomes the item we're working with inside the loop then we'll do some action on it go up and say, are there more objects? If so, put them in single object, do a thing with them. Go up again. Are there more items? No. Okay. Stop the for loop. For objects we don't have a for each method or anything like it. That's because objects generally are structured differently than arrays, but using for in we can still loop through them. So now you have four different ways of iterating through arrays and objects, and you can experiment with all of them to see which one fits your work process the best. Right now the popular standard is to use for each methods for arrays and for in statements for objects. But these are just opinions. You can use the other approaches as well.

### Using the map() array method
 
- [Instructor] The map method for arrays to serve special mention because it is heavily used when working with complex lists of data and when using frameworks like React. The map method takes an existing array, then does something to each of the items in the array and returns each of those items into a new array. In contrast, for each array method we looked at earlier loops through the array but doesn't create anything unless we explicitly tell it to and nothing is ever returned into something else. So if we need to create a new array with the items from an existing array and we want to change those items in the process, we use the map method. Looking at our foreach example from earlier, you see we use the foreach loop to loop through each of the items. Then we create a new element for each item, insert the item value into that element the "li" and then we append that item immediately to the stuff list ul so that it appears. But in many cases we may want to do this differently. Maybe we want to first create those new elements and then maybe do something else and then append them directly to create element. For that purpose, we would use the map method instead. So let's see how this would wire together. First, I want to change this foreach loop into a map loop. To do that, I need to create a new constant and place the map loop inside that constant. So I'll say const, we'll call this one stuffItems equals. Then right now we have stuff foreach, so I'll change that to stuff map. And then change this to map array method. All right, now we want to do the same things. We want to create that list item and populate the list item with the value of the individual item we're looking at. But instead of appending it directly to the stuff list ul immediately, we want to return this new list item back to stuffItems to create a new array. So I'll cut this out because we'll use it later. And then I'll say return listItem. Now, when we run this, we'll get a new array called stuffItems that has each of the items from our stuff array, but with an li appended around it. We can then try to output all this stuff. So we'll say console.log, and then we'll say stuff first, and then console.log stuffItems. That's the new array we just created using map. Save that, go into our console. And here you see we now have two arrays. The first one has just items. The second one has list items and inside each list item, we scroll down here you're going to see the value of each of these list items is whatever it is. So in this case, indexHTML, piggy, and so on. And each of these list items is a proper object inside the DOM that we can then apply somewhere. Now that we have a new array with the list items, we need to use foreach loop to loop through each of them and then append them to the stuff list ul. So I'll say stuffItems.foreach. Then we grab each item, create an arrow function, and inside each item you want to grab stuff lists, that is the ul up here and append the list item to that item. Sorry, this is the item now, like that. Save, and now we get the same response as we did before. So why on earth would I want to do this? This just made the process more complex? Well, the reality is, in many cases simply iterating through an array and outputting the content right away is not what you want to do. More often than not, you want to create a more complex array first and then perform other actions on that array before you output it to the browser or do whatever you want to do with it and that's what the map method is for. Now that you know how to use the map method, a caveat. You'll see the map method used a lot in modern JavaScript especially in JavaScript frameworks. And a lot of the time it's used to just iterate through an array just like we did with the foreach method. This is an anti-pattern and it should be avoided. Map is specifically for when you need to create a new array to do something further with the data. If you just want to iterate through an array, and then output the content right away, use a foreach loop, that's what it's for. The reason people are using map like this, is quite simply that map is a trendy new tool and people like to follow trends. What can I say? People do weird things sometimes. So if you need to iterate through an array, use foreach. If you need to create a new array, out of an old array and do something to each of the items before you do so, then use map.
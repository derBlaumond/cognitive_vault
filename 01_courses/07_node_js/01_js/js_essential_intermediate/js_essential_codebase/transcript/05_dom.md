### DOM: The Document Object Model
 
- When we humans encounter objects in the real world, we create models of those objects in our minds. Just think about it. If I say the word backpack, you immediately have a prototypical model of a backpack in your mind. What that backpack looks like and how it functions and what it contains will be different from each person, but the overall model is the same. A bag of large-ish size with two straps on the side that you can put over your shoulders. And here's the thing, that mental model of an object, the object model, gets more complex and detailed the more we know about the object. So if I take this backpack and open it to show you the pockets and features inside, you'll immediately develop a more advanced object model for this particular backpack and what goes inside. Just watch. Let me just close up this backpack. And then I say, "Help me find the pig." Even though you can't see it, you've established an object model for this backpack, complete with a robust hierarchy, and you can use that to not only find the pig, but even explain to someone else how to find it. I want you to do this for me right now. Take out a piece of paper and a pen, and imagine you're writing a set of instructions to a complete stranger on how to find the pig inside this pack. Start with, "Grab the gray backpack," and then list out each step necessary to get to the pig. I'll wait. Okay, that's enough. Now, you and me, we've probably never met, right? And there is literally no way I could possibly have seen what you wrote down because I'm here in my house recording this months before you're watching it. Agreed? Even so, I'm pretty sure I can make a list of steps to match yours very closely. Let's see. Number one, grab the backpack. Number two, open the right side panel. Number three, open the zipper inside the panel. Number four, take out the black pouch. Number five, here's the pig! Now, we humans naturally organize all the objects in the world around us in logical hierarchical structures. This is why, if you come to my house and I say, "Can you get me a spoon?" You would immediately go to the kitchen and start looking in the top drawers, because in most cases, due to their shape and their frequency of use, that's where cutlery is stored. What we have in the example of the bag and the example of the kitchen are hierarchical trees with a trunk, branches, finer branches, and eventually leads. What on Earth does any of this have to do with JavaScript? Everything! You see, when you present a web browser with an HTML document, the browser does the exact same thing we just did. It creates an object model for the document, a document object model, or DOM for short, and this DOM describes the hierarchical tree structure for that document, how the different elements in the document relate to each other and are nested. It is so similar, in fact, I can make an HTML representation of this backpack, and then find the pig the exact same way we just did in the real world. This right here, being able to traverse the document object model tree to find the element or elements you're looking for, is an essential skill when working with JavaScript. Because, just like your friend who has never seen this backpack before, you need to be able to tell JavaScript exactly what to look for, the pig, and where to find it, in the right side panel inside the zipper in the black pouch.

### Access elements with querySelector methods
 
- [Instructor] Let's take a look at how to access elements in the DOM using JavaScript. In the exercise files for this movie, I've updated our examples so we have some actual content to work with. I've added some basic HTML and a style sheet in index.html and I've also expanded the HTML output in the template literal a little bit to make it possible to style it. I've added some classes. I've wrapped spans around the values, and I've also added an image at the top here. Looking at the project site in the browser you'll see, it looks quite different but there's nothing new here in terms of JavaScript. I've just expanded on what we've covered so far in the course. All right, anytime you want to do something in the DOM you start by finding the element or elements you want to work with. For this, we have two methods: query selector and query selector all. And they both apply to the document object. These methods use standard CSS queries to climb through the DOM tree and find the specified elements. So if you know how to target things with CSS you also know how to target things using JavaScript via these methods. That's what makes them so powerful. Let me show you how this works. Let's say I want to target the main that wraps around the main content in this document. I can go to my console, grab the document object, and then use the query selector method The query selector and query selector all methods, both take a CSS query as their parameter and it's put inside quotation marks so we can put in a proper string. So here, because I'm targeting an element I'll just type in main. And this immediately gives me the main element. Hit return and you can see when I hover over this element it gets highlighted in the browser because this is the actual element the browser is showing me. And I can then dig into this element and see to the article, to figure, just to each one and so on. The query selector method has returned a DOM object to me, and it is a pure JavaScript object I can then work with just like any other JavaScript object. Now, in this example, I targeted an element. I can also use the same method to target a class. So again document, query selector, only this time, I'll say .maincontent. It'll give me the same element, only this time I got it using the class name instead. What's cool about this is I can use any CSS query here. So if we look at our example, you'll see we have a list here, an unordered list. Let's say I want just the last list item. In that case I'll say document, query selector, and then say I know that it's inside the main, so main, and then I want L I, last child. Hit return and it gives me just that last child of the list. Inquiry selector, all CSS selectors and all CSS selector combinations work just like they do in CSS. This is basically using CSS in JavaScript. The query selector method I've used so far returns the first elements that matches the query we're passing, so we get one element and one DOM object in return. If we want to get a list of objects let's say all the list items or some other array of objects, we use the query selector all method instead. This one returns to me a node list which looks like an array that has all of those objects. So let's say we want all the list items here. In that case, let me just clear this. In that case I say document, query selector, all and then we'll say main L I. Now I get a node list and inside the node list, I have each of these items. Now I can go through them one at a time to see what's going on. Now that I have a node list, I can use a different method like for each to go through that list and do something to each of the items. So again, we're skipping ahead a little bit. We'll cover this function in more detail later on in the course, but I want to give you a preview. So I'll say document, query selector, all, just like I did before and target main L I. Then I'll append the for each array method on this. And inside for each, I'll say for each of the items, I want to set the item style, background color equal to red. Hit return. And now you see that each of the items have gotten the red background color. Now, just to show you, I'm not cheating, I can now go in here and change this to say, just last child and then give the last child the color blue maybe. And here you see, I can target just that last item. So even though I have a list of items I can still target either each of them or go through all of them and do something to them using JavaScript. And this is what makes these two methods so powerful. I now have access to any element in the document object model and I can do whatever I want to any of those elements at any time using JavaScript. Before you continue, I urge you to play around with these two methods in the console right now. You've seen how they work and now you can use them to target all those elements. Remember, I've expanded the HTML in this example specifically so you can target different things. So try to find the element that has to class background underscore underscore color or all the spans in the project or something else and see if you can get to target those individual items. Like I said, query selector uses CSS queries. So if you know how to target things with CSS queries you know how to target them using JavaScript.

### Access elements using older methods
 
- [Instructor] In tutorials and code examples, and even live code you will often find two other methods used to access elements, getelementsbyClassName and getelementbyId. Notes that get elements by class name has the plural of elements whereas the by id one has the singular of element. These two methods used to be the only tools we had for accessing elements using classes and ids and they still work, but queryselector and queryselectorall were introduced to simplify this process and remedy some of the shortcomings of these older methods. That said they still work fine they're just falling out of favor because the queryselector method work better and easier. Lets look at how these older methods work, getelementsbyClassName returns an array-like object of all the nodes or child elements matching the query. The query is string of space separated class names. Looking at the exercise file for this moving you will see I have added the packprop class to some of the list items in our list. We can now use getelementsbyClassName to find only those elements. To do that open the console, target the document object cause that gives us everything in the document and then we say getelementsbyClassName and then we pass in the class name we are looking for packprops, I mean packprop there we go. Here now we get an htmlcollection of elements, now an htmlcollection is similar to the node list we got with queryselectorall and it works pretty much the same way it just that this is an older way of doing things, the browser is returning an older type of object back to us we can still use the foreach loop to loop through these and we can still do all the other things, so it's effectively the same thing just in a different method. Okay, so this query gave us all the items, now let's say I want to get only a specific item that has both this class and another class. Lets look back and say maybe we want the one that also has backpack color so I will say packprop backpack color, I will go back into my console hit the up arrow to just get my old query and then I will paste and this two class names instead, what we get in return now is the same an htmlcollection only now there is only one item and that is the item that has that specific combination of classes. So using getelementsbyClassName we can get a single element but we get a return as an array and then we have to iterate through that array to get to the single element. Say document getelementsbyId and pass in the name of that id hit return and we get the document object this time of the id. Now that you see how these works you will also notice in older code, developers often used ids specifically to be able to target objects like this because like I said we used to only have these two methods and the class method gives us an htmlcollection that we then have to work with further to get to the object that means in some older code you will find html documents are full of ids simply so that we can target them using this particular method but now that we have the queryselector and queryselectorall methods we no longer need to comply with the restrictions of these two methods and we can do whatever we want using C S S query instead which is why we use queryselector and why these two older methods are relegated to the past.

### Practice: Find an element
 
- Traversing up and down the DOM tree to find one or more elements is going to be something you do all the time when working with JavaScript. So I want this to become second nature to you. Now that you're familiar with the main methods we use to find elements in the DOM, the querySelector and querySelectorAll methods, I want you to take some time to familiarize yourself with how powerful and exacting these methods are by finding elements in an HTML document. In the practice files, there's a standard HTML document with a bunch of different elements and classes. This is your playground for finding objects and working with them. Here's what I want you to do. In the browser, identify a specific element or a set of elements you want to target. Use the console or the script.js file if you wanted to get more advanced to find those target elements. Then move beyond the basics. Try targeting specific elements nested inside other elements, and use advanced CSS queries to get just what you want and nothing else. Make sure to experiment with both querySelector and querySelectorAll to see how they work differently and what type of data you get in return. And if you want to try something really advanced, try populating a variable with an element higher up in the DOM tree hierarchy, and then use a querySelector on that variable to find one of its children.

### Modifying element classes
 
- [Instructor] A common task in JavaScript is to modify the classes of an element in some way. This is a simple way of changing the appearance or behavior of an element without having to inject CSS into the HTML itself. Instead, we just add a class or remove a class to make something happen. Examples of this include hiding and showing a panel, or highlighting a button when something else has happened, like now that you've done step one, click here to continue, et cetera. Class manipulation is common enough, that we have two specialized properties for it. The first one and the oldest one is class name, and it's available for all elements in the dom. Class name holds a string, listing out all the classes appended to an element. We can see it if we go to our exercise files and the console. So the H1 here has the class backpack name, and we can call up the H1 in JavaScript and get just that output. So document, query selector, H1. Now we have the whole element. Then I can call for the class name property and I get just backpack name as a string in return. Now this is a property, meaning I can reset this property and reassign it any other value. So if I want to, I can say equals and then put in a different value, and watch what happens up here in the Dom when I hit return. The class Changes because I'm reassigning the class name property. This is really powerful. It's also a bit problematic. There are two challenges with using class name. First off, if you have an element with several classes like we have here in the UL, we have several elements that have several classes, you can't just replace the classes with a new class, because that way you're wiping out all the classes, you're exchanging all the content within the property for some other content. So if you have a property with several classes and you want to just change one of the classes you have to somehow go in and parse out which classes you want to keep, and which ones you want to change and it gets really clunky and requires a lot of code. The other problem is even more serious. In React and other JavaScript frameworks, the term class name is used in place of class in markup to avoid collisions with the JavaScript class keyword which is used to set up classes. This means if you're trying to target the class name property, but you're inside a JavaScript framework, you're actually doing something else which can cause unexpected behavior and will not result in what you want. As a result we really shouldn't be using the class name property in frameworks, and we should be careful about using the class name property anywhere else as well. Instead to get around both of these problems, we can use the class list property. The class list property gives us a Dom token collection of all the classes appended to an element. Let me show you what that means. If I go back to my code example here, let's go back to the browser and try to target an element that has multiple classes, like the first element in the list here. If I now call the class list property, you'll see I get a Dom token list, it's an array listing out each of the classes in turn. That means I can now work with each of these classes individually, and I'm not required to replace the entire string. What makes this property even more powerful is it comes with its own set of methods to manipulate the individual classes. So if I want to add a new class, I can use the add method. I say, class list dot, add, and inside I specify what class or classes I want to add. So I want to add new class. And you can see, the new class is added automatically. There's also a remove method. So if I say remove, I remove that class, there's also a toggle method, so if I want to add a class, if it's not there, and remove it, if it is there, I can use the toggle method. So watch up here when I hit it once, it's added if I hit it again, it's removed. And finally, there's a replace method where I can specify a class and then replace it with a different class. So I can say replace and then the first item will be the class I want to replace. So pack prop, comma and then the second item is the class I wanted to replace it with. So again, watch the item up here. I hit return, pack prop goes away and in place we have new class. Here's the bottom line. If you want to add, remove, toggle or replace classes you should always use the class list property, and use the methods that come with it. If on the other hand, you're looking for a string and you want just the output of all the classes to do something else with, you can use the class name property. So in almost every case you want to use class list.

### Attributes
 
- [Instructor] JavaScript can be used to modify the attributes of any elements. The attributes are stored in the attributes property, it can be accessed directly by calling it. One thing worth noting here is the attributes property returns a different type of data from the class name and class list properties. What we get is a named node map and it is not an array. So we can't use array methods on it. There's a simple reason for this. An attribute is a more complex piece of data, it has a key and a value and we need to be able to manipulate just the key or just the value or both at any time and a simple array wouldn't do that. Let's look at the attributes property first. So I'll select this image here 'cause I know it has attributes and has a source attribute and an alt attribute. Then we can call it in using JavaScript and look at what that attributes property contains. What I get in return is a named node map. Inside here we have the two attributes source and alt and we can open each of them and get a full breakdown of all the information the browser has about this particular attribute. So in this case, we have a node value of assets, images, everyday, svg which matches what you see up here. Now, looking at this, you're probably also wondering how am I supposed to work with this pile of data? All the good news is, for attributes we have dedicated methods to do all the things you would normally want to do. So let me show you how that works. First, let's test to see if the element has an attribute we're looking for. So we'll say again, document, query selector and look for the image. And then we'll say, has attribute and pass in the value of the attribute we're testing for, so source. If the element in question has this attribute the return will be true. If it doesn't have the attribute, so title, that's an image there it shouldn't have a title and it doesn't. So we get false. So this is an easy way of testing does this attribute exist on this particular element. All right. So now that we know it has the attribute I want to see what that attribute contains, for that I can say, get attribute then we specify what attribute we're looking for and the browser will return the value assigned to that attribute. So in this case, it is the URL. And if I change this to the alt attribute, you'll see, even though it's blank up here, it actually contains something and contains the beginning and end quotation marks because this is an empty alt attribute. I can also set an attribute here. I can either set the value of an existing attribute or create a new attribute altogether. I do that using the set attribute method, here I first name the attribute I want to set then I add a comma and then put in whatever value I want to attribute to that attribute. So here I want to add text to the alt attributes. So I'll say, a drawing of a backpack, hit return and now that new value is appended to the existing attribute. I can use the set attributes to create new attributes as well. So if I go back here and say set attributes title. Now again, this is an image element, so it shouldn't have a title but I'm going to do this anyway. And then set the title to, this shouldn't be here and hit return. You'll see now the image gets a new attribute called title that has the value this shouldn't be here. All right. Now that I've added this attribute that shouldn't be here, I should really remove it as well. So I will say, remove attribute title and hit return. The title attribute is removed between has attribute get attributes, set, attribute, and remove attribute. You have all the functions you need to be able to manipulate any attribute inside a tag. And note here that, everything inside the tag is considered an attribute. That means if we target an element that has a class, the class will also show up as an attribute and we can actually use these attribute methods to manipulate classes if we want to. Now, keep in mind we have dedicated the properties and methods for classes but if you need to, you can also use all of these attributes to manipulate classes in any element.

### Inline style
 
- [Instructor] If an element has inline styles meaning there are CSS declarations in the element itself that inline CSS is stored in the style property of the elements, and we can access it as a regular property in the exercise files for this movie I've added an inline style to the site title. You see it here. We have a div class site title style, color black. I can now lift out that style information using the style property on that element. Now, what I get in return here is a CSS style declaration which is a list of all the available possible style properties that could be applied. And then a specification of which ones are actually applied. So here you can see color property applied. And if I scroll way down on this list here let's see all the way down here. You see color is at the black. So this is not the most useful list possible but it does indicate what we can use this for. Because what you're seeing here is the CSS style declaration object contains every possible property. That means I can call up any of these properties specifically because it is just a property of an object and then set that property directly. So right now, when I called for a style dot color using dot notation I get the result black. If I, again called style dot color and set it to something else like Rebecca Purple watch what happens. The color now changes to purple because we're just setting the property. And what also happened is inside a style declaration here in the element, the color declaration changed this year, targeting the individual style properties is the recommended way of handling inline styles because it allows us to modify just that property and nothing else. I say this because you can technically assign a new value to the style property directly if I go and request just a style property again and we take another look at this CSS style declaration you'll notice way down here there is. Let's see here there's a property called CSS text, and this is the actual text that sits inside the style property. So if I now to find a different style, in addition you'll see it gets upended here. So if we collapse this, let's see here and then clean this up and then say, we want to set style background color equal pink and hit return. Now we have two style declarations both color and background color. And if I then go and call in just style again and scroll way down here we have CSS text and it literally spells out what is in the text of the style property up here. So technically if I have one too, I can also just set this property CSS text and put in all the style declarations in one go. But like I said, the recommended approach here is to set each individual CSS property individually, because then you have one way control. One more note here. If you look closely at the CSS properties listed in this CSS style declaration property, you'll notice that there are no hyphens. I remember way back when we talked about property names and I said, you can't have hyphens. It applies here. So instead of hyphens, all the CSS properties have been camel cased. So background color is not background dash color instead it's background and then a capitalized C color. And you can see here the list of all the available properties and what they are. So if you want to set a CSS property and you wonder what is the correct property name, all you have to do is go through the elements in question and just call the style property. You get the full CSS style declaration list, and then you can scroll down and find the property name you're looking for and use that to target that particular property.

### Working with data-* Attributes
The cool thing about HTML elements is you can add as many attributes as you like to any one of them, and then use JavaScript to create, read, update, modify, and delete them at will. It's useful to think of these attributes as feature lists for the element. Each attribute can change the element's behavior or appearance or even relationship with other elements.

As we've already covered, for a standard HTML element, its attributes can be manipulated using methods like getAttribute(), setAttribute(), and removeAttribute(). These methods allow you to interact directly with the element's attributes by dynamically editing the HTML source code without reloading the page.

Given the following HTML element...
```html
<button id="myButton" class="btn btn-primary" type="button">Click Me!</button>
```
...you can manipulate its attributes like this:
```js
const button = document.querySelector("#myButton");

// Get the value of the 'class' attribute
console.log(button.getAttribute("class")); // "btn btn-primary"

// Overwrite the value of the 'class' attribute
button.setAttribute("class", "btn btn-secondary");

// Remove the 'type' attribute
button.removeAttribute("type");
```
These manipulations serve as straightforward examples of a much broader and more powerful concept. In addition to describing the element by adding basic attributes like classes, attributes can be used to store custom data and even define roles for accessibility. One common use of this feature is to create custom data attributes with a data-* prefix and retrieve them using the dataset property.  

As an example, in the below example a custom data-sku attribute is appended to each available product, and the SKUs of the selected products is passed on when the submit button is pressed:
```html
<form id="productForm" onsubmit="submitProducts(event)">
  <fieldset>
    <legend>Select products:</legend>

    <label for="product1">
      <input type="checkbox" id="product1" class="product" data-sku="SKU1234" />
      Product 1
    </label>

    <label for="product2">
      <input type="checkbox" id="product2" class="product" data-sku="SKU5678" />
      Product 2
    </label>

    <label for="product3">
      <input
        type="checkbox"
        id="product3"
        class="product"
        data-sku="SKU91011"
      />
      Product 3
    </label>

    <button type="submit">Submit Selection</button>
  </fieldset>
</form>
```
```js
<form id="productForm" onsubmit="submitProducts(event)">
  <fieldset>
    <legend>Select products:</legend>

    <label for="product1">
      <input type="checkbox" id="product1" class="product" data-sku="SKU1234" />
      Product 1
    </label>

    <label for="product2">
      <input type="checkbox" id="product2" class="product" data-sku="SKU5678" />
      Product 2
    </label>

    <label for="product3">
      <input
        type="checkbox"
        id="product3"
        class="product"
        data-sku="SKU91011"
      />
      Product 3
    </label>

    <button type="submit">Submit Selection</button>
  </fieldset>
</form>
```
Custom data attributes are frequently used in JavaScript frameworks and libraries to store additional information about an element. They are also used to define roles for accessibility, such as aria-* attributes. These attributes are used to provide additional information to assistive technologies like screen readers, making the web more accessible to users with disabilities.

### Practice: Modify classes and attributes, and styles
 
- Being able to quickly access, modify, add and remove classes, attributes and inline styles from any element in the DOM, is a bit like having a bag of tools on hand to solve pretty much any problem. Need to indicate a state change of an element? Add or remove a class. Need to pass data from one element to the other? Add a data attribute. Need to change the appearance of a specific element for some reason? Add an inline style. In the previous practice assignment, you familiarized yourself with accessing DOM elements using the query selector and query selector all methods. Now I want you to take this one step further by actively modifying the elements you've targeted by adding or removing classes, attributes, and inline styles. Here's some examples of what you can do. Find an element and add two different classes then remove only one of those new classes. Add a new attribute to an element. This can be a standard attribute like source or alt if that's appropriate for that element or it can be a data attribute passing literally any data you want. By the way data attributes follow the naming convention data dash and then the name of the attribute. Request the value of the attribute you added. Change the value of that attribute you added. Add some inline CSS to an element by specifying the style property and setting its value. And finally query the style of property of an element in the console to get a list of all the style properties available to you.

### Add DOM elements
 
- [Instructor] In the example project, I used this template literal to create HTML and then added that HTML to the existing document by targeting an existing element and replacing its internal HTML using the inner HTML property. All that functionality is down here, and we've now covered all the features that make this possible. This is an effective way of injecting new HTML into a document, but it's also rather crude and destructive. It requires an existing element to be in the HTML documents, and it wipes up whatever code was contained inside that element. And that can be a problem. Let me show you what I mean. In the exercise files for this movie, I've added a short intro text to the main section of the document. This new text sits inside the main element. And the problem is when we inject the backpack content using JavaScript, we're replacing all the content inside the main element, so this new text disappears. You can see that if you go to the browser the new text is nowhere to be found because we replaced it. What I want to do instead, is to add the backpack content inside the main, to appear after all the other content, so after this new div called page header. To get this to work, I need to add a new DOM element, and place it exactly where I want it to appear in addition to what is already there in the document. So instead of a destructive process, I want to use on process that creates new content. DOM manipulation like this, is an essential part of JavaScript. So there's a huge toolkit of methods available for just this purpose. So here's what I want to do. First, create a new element for the backpack content, it'll be an article. Then populate that element with classes, IDs, and content, and finally somehow append that new element to the existing document. It all starts with this method here, create element. In the JavaScripts, I go down towards the bottom, and I set up a new constant called new article, and I set it equal to documents, creates, elements, and then I just name what type of elements I want. So in this case, it's an article. This will create a new article on the DOM, but it's not placed anywhere. So it kind of exists in theoretical space until we use it. Now that we've created this new article, I'm also going to take the article out of the template literal here so we're not doubling the article. Then I want to append a class to this new article and I can do that using the methods we covered previously. So new article, class list, new and... sorry, add... and here we want backpack. And then I also want to add an ID and we do that using set attributes. So new article again, set attributes. This is an ID and the value should be every day. And finally I want to place the template literal content inside this element. I already did that with the main. So I'll just change this to new article. And that way the inner HTML of the article is set to this template literal. Okay, so now we have an element with a class and an ID and content. The next thing we need to do is somehow append this new element to the existing content. So it is appended to the main to appear after this div with the class page header. That's done using the parent Node append method. This method takes the parent Node, in our case the main and then it appends whatever we want to the end of that main as the last child. And that's exactly what we want to do here. So we already have the main defined up here, document query selector, main content. I'll grab main and say append, and then append new article. All right, save that, go back in the browser and test it and look at that. Now we have the main content and the appended backpack and this is possible because we created a new element and then added that element into our document. The append method can be used to add one or several comma-separated elements and they all go at the end of the parent Node. And it can also be used to append a string of texts if that's what you want to do. If on the other hand you want to add an element as the first child of the parent, you can use the parent Node prepend method instead, it does the exact same thing. Just places the element at the top instead of at the bottom of the parent element. If you need to move an element from one location to another inside the DOM, or you need the browser to return the appended object to be further worked with, you can also use the append child method. The only difference is it also returns this element to you. There are also several other methods for this type of manipulation and their names pretty much explain what they do. We have replace Child, which replaces a child element of a parent. We have insert Before, which allows us to insert an element before the parent elements. And we have insert Adjacent. Now these two last ones are interesting because they give you the capability of adding new elements before or after other elements rather than just inside them. In particular, insert Adjacent Element is extremely powerful because you can specify exactly where you want that new element to appear, inside or outside the target element.
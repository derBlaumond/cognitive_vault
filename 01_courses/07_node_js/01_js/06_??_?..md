좋아. 붙여준 스크립트를 바탕으로 **널 병합(??)** 과 **옵셔널 체이닝(?.)** 을 실무 관점에서 정리해줄게.  
구성은 **개념 → 동작 규칙(한줄 요약) → 코드/실행 결과 → 자주 틀리는 포인트 → Node/Express 실전 패턴 → 연습 과제 & 체크리스트** 순서야.

---

# 18. 널 병합(??) & 옵셔널 체이닝(?.)

## 1) 왜 쓰나 — “짧고 안전한 접근 + 올바른 디폴트”

- **`??`**: _정말 값이 “없을 때만”_ (정확히 `null` or `undefined`일 때만) 기본값으로 대체.
    
- **`?.`**: _존재할 수도 없는 경로_를 **예외 없이** 따라가거나 호출.
    

이 둘만 익숙해져도 `if`/`try` 도배가 사라지고, 0/'' 같은 “정상 값”이 실수로 덮어씌워지는 버그가 줄어든다.

---

## 2) 동작 규칙 한 줄 요약

### 널 병합 `??`

- **왼쪽이 `null` 또는 `undefined`일 때만** 오른쪽으로 넘어간다.
    
- `0`, `false`, `''`는 **유효한 값** → 넘어가지 않는다.
    

```js
0 ?? 42        // 0
false ?? true  // false
'' ?? 'N/A'    // ''
null ?? 7      // 7
undefined ?? 7 // 7
```

### 논리합 `||` 와의 차이

- `||`는 **Falsy(거짓 같은 값) 전체**(0, '', false, null, undefined 등)에서 넘어간다.
    
- `??`는 **nullish(정말 비어있음)** 두 가지만 넘어간다.
    

```js
0 || 10   // 10  (실수로 덮임) 
0 ?? 10   // 0   (의도 보존)
```

### 옵셔널 체이닝 `?.`

- **왼쪽이 nullish(null/undefined)** 이면 **즉시 `undefined` 반환**하고 더 안 들어간다.
    
- 점(`?.`), 인덱스(`?.[key]`), 호출(`?.(…)`) 3가지 형태가 있다.
    

```js
user?.profile?.email           // user 또는 profile이 없으면 undefined
user?.roles?.[0]               // 안전한 인덱싱
user?.notify?.('hello')        // notify가 함수일 때만 호출
```

---

## 3) 스크립트 핵심 상황을 코드로 재현

### (A) 0을 기본값으로 인정해야 하는 UI/로직

```js
const count = 0;

// 잘못된 예 (||): 0을 덮어쓴다
const display1 = count || 123;   // 123 ❌

// 올바른 예 (??): null/undefined만 덮어쓴다
const display2 = count ?? 123;   // 0 ✅
```

### (B) 깊은 경로 접근에서의 예외 방지

```js
// 에러: Cannot read properties of undefined (reading 'd')
const value1 = a.b.c.d;

// 안전: 어느 경로가 없으면 그냥 undefined
const value2 = a?.b?.c?.d;

// 배열/인덱스/호출에서도 동일
const first   = list?.[0];
const result  = maybeFn?.(arg1, arg2);
```

> 형태는 항상 **`?.`**(물음표+점)이다. `a?['x']`처럼 **물음표만 단독**은 문법이 아니다 → **`a?.['x']`**처럼 써야 함.

### (C) `?.`와 `??`의 조합

```js
// user.profile.email이 없으면 'unknown'으로
const email = user?.profile?.email ?? 'unknown';
```

---

## 4) 자주 틀리는 포인트

1. **에러 메시지 오독**
    
    - “Cannot read properties of **X** (reading 'd')”에서 **X가 nullish**인 것.  
        예: `c.d`에서 에러면 **c가 nullish**(d가 아님).
        
2. **`??`와 `||`의 혼용**
    
    - 디폴트가 “0/''/false도 허용”이면 **`??`**,  
        “0/''/false도 허용하지 않음”이면 **`||`**.
        
3. **`?.` 위치**
    
    - 점 앞에 붙인다: `obj?.prop`, `obj?.[key]`, `fn?.()`.
        
    - `obj?prop`는 문법 오류.
        
4. **체인 남발**
    
    - 무조건 모든 점에 `?.`을 붙이면 가독성이 떨어진다.  
        “정말 nullish 가능성”이 있는 경로에만 쓰기. TS 도입 시 컴파일러가 힌트를 준다.
        

---

## 5) Node.js / Express 실전 패턴

### (1) 요청 파라미터/바디 안전 접근 + 기본값

```js
app.get('/search', (req, res) => {
  const q    = req.query?.q ?? '';
  const page = Number(req.query?.page ?? 1);
  const size = Math.min(Number(req.query?.size ?? 20), 100);
  res.json({ q, page, size });
});
```

### (2) 외부 API 응답 셰이핑

```js
const data = await fetchJSON();
const price = data?.product?.pricing?.discount?.amount ?? 0;
// 필드가 빠져도 터지지 않고, 계산 로직이 단순해진다.
```

### (3) 선택적 콜백/후크 호출

```js
function process(item, hooks = {}) {
  hooks.before?.(item);
  // ... 작업 ...
  hooks.after?.(item);
}
```

### (4) 환경변수/설정 주입

```js
const cfg = {
  host: process.env.DB_HOST ?? 'localhost',
  port: Number(process.env.DB_PORT ?? 5432),
  ssl : process.env.DB_SSL?.toLowerCase() === 'true',
};
```

### (5) 안전한 로깅

```js
logger.info(`[req:${req.id ?? 'n/a'}] user:${req.user?.id ?? 'guest'}`);
```

---

## 6) 실습 과제

1. **디폴트 처리 구분**
    
    - 아래 표현식의 결과를 예측하고, 왜 그런지 설명해라.
        
    
    ```js
    0 ?? 99;        0 || 99;
    '' ?? 'N/A';    '' || 'N/A';
    false ?? true;  false || true;
    ```
    
2. **안전 접근 + 기본값**
    
    - `order?.customer?.address?.zip ?? '00000'`가 언제 '00000'을 반환하는지 케이스를 나열하고, 각 입력 예시를 작성해라.
        
3. **옵셔널 호출**
    
    - 아래 코드에서 예외 없이 동작하도록 `?.`을 알맞게 배치해라.
        
    
    ```js
    const api = { notify: null };
    api.notify('done');     // 여기서 예외 없이 무시되게
    ```
    
4. **배열/인덱스 접근**
    
    - `const names = getTeam()?.members?.map(m => m.name)` 코드에서  
        `getTeam()`이 `null`일 때, `members`가 `[]`일 때 각각 결과를 설명해라.
        

---

## 7) 최종 체크리스트

-  `??`는 **null/undefined에서만** 기본값으로 넘어간다는 걸 정확히 안다.
    
-  `||`와의 차이를 예제로 설명할 수 있다.
    
-  `?.`, `?.[key]`, `?.(…)` 세 형태를 구분해 쓸 수 있다.
    
-  깊은 경로에서도 예외 없이 안전하게 접근/호출할 수 있다.
    
-  `?.` + `??` 조합으로 **안전 접근 + 디폴트**를 한 줄에 구현할 수 있다.
    
-  실무 코드(요청 파싱, 외부 응답 셰이핑, 로깅)에서 적극적으로 적용할 수 있다.
    

---

다음은 **19. 프런트엔드 자바스크립트**로 넘어가서 브라우저 환경(이벤트 루프 차이점, DOM, 모듈/번들링, 성능)에 연결해볼 수 있어. 계속 진행할까?
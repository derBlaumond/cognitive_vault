## Callback Function
### 콜백 함수 정의 및 고급 함수 개념과의 연관성

콜백 함수는 **다른 함수의 인수로 전달되어 그 함수 내에서 실행되는 함수**를 의미하는 용어입니다. 이는 자바스크립트의 핵심 특징인 함수가 **일급 객체(first-class citizens)**라는 개념 덕분에 가능합니다.

자바스크립트에서 함수는 호출될 수 있는 힘을 가진 객체입니다. 함수는 다른 데이터 타입처럼 값으로 취급되어 전달되거나, 변수에 할당될 수 있으며, 이러한 특성 덕분에 콜백 함수로 활용될 수 있습니다. 콜백 함수 패턴은 현대 자바스크립트에서 **"모든 곳에서(all over the place)"** 사용됩니다.

### 콜백 함수의 주요 사용 사례

콜백 함수는 동기적(Synchronous) 작업과 비동기적(Asynchronous) 작업을 처리하는 데 광범위하게 사용됩니다.

#### 1. 배열 및 반복 작업 (Array and Iteration)
배열 객체가 가진 내장 메서드는 콜백 함수를 인수로 받아 배열의 항목에 대해 반복적인 작업을 수행합니다.

*   **`map` 메서드:** 배열의 `map` 메서드는 콜백을 매개변수로 받습니다. 이 콜백 함수는 배열의 **모든 항목에 대해 순차적으로 실행**되며, 그 결과로 새로운 배열을 생성합니다. 이 `map` 메서드와 콜백의 조합은 사용자 인터페이스에서 목록 항목을 렌더링하는 데(예: React 프레임워크에서) 많이 사용됩니다.
*   **`forEach` 메서드:** `forEach` 메서드 역시 콜백을 인수로 받아 배열을 순회합니다. `forEach`는 `for` 루프보다 더 간결하고 표현력이 풍부한 반복 방법일 수 있지만, 반복 도중에 `break` 키워드를 사용하여 멈추는 것은 쉽지 않습니다. `forEach`는 배열의 각 값을 인수로 전달하며, 어떤 값도 반환하지 않습니다.

#### 2. 비동기 작업 및 지연 실행 (Asynchronous Operations and Delayed Execution)
콜백 함수는 시간이 걸리는 비동기 작업의 결과를 나중에 처리하기 위해 사용됩니다.

*   **`setTimeout`:** 전역 객체(브라우저의 `window` 또는 Node의 `Global`)에 있는 `setTimeout` 함수는 첫 번째 인수로 함수(콜백)를, 두 번째 인수로 밀리초를 받습니다. 이 콜백 함수는 타이머가 만료된 **후에 실행**됩니다. 함수를 전달할 때는 함수를 즉시 실행하지 않기 위해 괄호를 포함하지 않습니다.
*   **비동기 요청 처리 (콜백 지옥):** 네트워크에서 데이터를 로드하는 등의 비동기 작업을 처리하는 초기의 방식은 콜백을 사용하는 것이었습니다. 예를 들어, jQuery 라이브러리의 `get` 메서드는 URL과 함께 콜백 함수를 받으며, 이 콜백은 서버로부터의 응답을 인수로 받습니다. 그러나 하나의 비동기 요청이 다른 요청에 의존할 때, 이 콜백 함수들을 서로 안에 **중첩**시켜야 하는 문제가 발생하며, 이는 코드를 복잡하게 만들어 **"콜백 지옥(Callback hell)"**이라고 불립니다.

#### 3. 이벤트 처리 (Event Handling)
콜백은 프로그램에서 특정 상황이나 이벤트가 발생했을 때 코드가 반응하도록 연결하는 데 사용됩니다.

*   **이벤트 핸들러:** 클릭, 탭, 텍스트 필드에 텍스트가 입력되는(`keyup`) 행위, 또는 창 스크롤과 같은 이벤트에 응답하는 함수를 **이벤트 핸들러**라고 부르며, 이는 콜백 함수로 구현됩니다. 사용자가 텍스트 필드에 무언가를 입력할 때마다 콜백 함수가 실행되도록 연결할 수 있습니다.

### 콜백 함수 작성 방식 (간결성)

콜백 함수는 종종 함수 이름 없이 정의되어 사용됩니다.

*   **익명 콜백 함수:** 콜백 함수는 미리 정의된 함수(`doubleIt`과 같은)로 전달될 수도 있지만, **익명 함수(Anonymous Function)** 형태로 인수에 직접 삽입되어 정의되는 경우가 많습니다.
*   **화살표 함수와의 시너지:** 이러한 익명 콜백 함수는 **화살표 함수(Arrow Functions)** 구문을 사용하여 더욱 간결하게 작성될 수 있습니다. 화살표 함수는 함수를 정의할 때 키 입력 수를 줄여줍니다.

---

## 비동기 코드 (Asynchronous Code)

JavaScript에서 **비동기 코드**는 복잡하거나 시간이 오래 걸리는 작업을 처리할 때 애플리케이션의 응답성을 유지하기 위한 현대 JavaScript의 필수적인 부분입니다.

### 1. 비동기 코드의 개념 및 필요성

일반적으로 코드가 작성된 순서대로 실행되며 한 단계가 완료될 때까지 다음 단계의 실행을 막는 방식은 **동기적(synchronous)**이라고 불립니다. 대부분의 코드 작성 방식은 이러한 선형적인 사고방식(linearly)을 따릅니다.

하지만 때때로 특정 단계가 완료되는 데 시간이 오래 걸릴 수 있으며, 뒤따르는 단계가 즉시 그 결과가 필요하지 않은 경우가 있습니다. 이처럼 **일부 단계가 동시에 실행될 수 있도록 허용**하여 다른 단계의 실행을 막지 않는 코드를 **비동기적(asynchronous)**이라고 합니다.

### 비동기 처리의 필요성

*   **시간이 걸리는 작업:** 비동기 작업은 코드가 **데이터를 어딘가에서 로드해야 할 때** 주로 필요합니다. 이는 인터넷상의 서버(예: 상점의 재고 데이터, 카탈로그의 사진)에서 데이터를 로드하는 경우가 대부분입니다.
*   **시스템 응답성:** 네트워크나 다른 데이터 소스는 때때로 느릴 수 있습니다. 만약 모든 코드가 데이터 로드를 기다려야 한다면, 전체 페이지가 느려지거나 **응답하지 않는 것처럼 느껴지게** 되어 사용자 경험에 부정적인 영향을 미칩니다.
*   **Node.js 환경:** Node 환경에서는 디스크에서 파일을 로드하는 것조차 기본적으로 비동기 작업으로 간주됩니다. 이는 디스크 작업이 상대적으로 느릴 수 있기 때문입니다.

비동기 작업은 인간이 매우 짧다고 생각할 수 있는 지연(몇 초 또는 심지어 몇 초의 일부)조차도 비동기적으로 처리하는 것이 **눈에 띄게 더 나은** 결과를 가져올 만큼 컴퓨터 용어로 '오래 걸리는' 작업에 해당합니다.

### 2. 비동기 코드 처리 방식 (고급 함수 개념 활용)

중급 또는 고급 JavaScript 코드를 작성하기 시작하면 비동기 코드를 작성하는 다양한 방식을 다루게 될 것입니다.

#### A. 콜백 (Callbacks)
비동기 작업을 처리하는 가장 초기 방식 중 하나는 콜백 함수를 사용하는 것이었습니다.

*   **동작 방식:** 비동기 작업을 수행하는 함수에 **콜백 함수**를 인수로 전달합니다. 서버로부터 응답이 오면 이 콜백 함수가 실행되며, 서버 응답을 인수로 받습니다.
*   **단점 (콜백 지옥):** 하나의 비동기 요청이 다른 요청에 의존하는 경우, 콜백 함수를 서로 안에 **중첩**시켜야 합니다. 이러한 상황은 코드를 작성하기 힘들게 만들고, 이해하기 어려운 코드를 만들게 되며, 이를 **"콜백 지옥(Callback hell)"**이라고 부릅니다.

#### B. Promise (프로미스)
Promise는 콜백 지옥 문제를 해결하기 위해 도입된 **비동기 작업의 결과를 포착하는 객체**입니다.

*   **동작 방식:** Promise 객체는 **API (특정 프로그래밍 인터페이스)**를 제공하여 약속된 데이터가 성공적으로 전달되었을 때 또는 실패했을 때를 처리할 수 있도록 합니다.
*   **`.then()` 체이닝:** `Promise`를 반환하는 메서드(예: `Axios` 라이브러리의 `get` 메서드)를 사용한 후, `then` 메서드를 직접 연결(chain on)합니다. 이 `then` 메서드는 데이터가 반환될 때 실행되는 콜백을 포함합니다.
*   **재귀적 체이닝:** 만약 해당 콜백 함수 내에서 또 다른 요청을 수행해야 한다면, **다른 Promise를 반환**할 수 있으며, 이로써 첫 번째 `then` 메서드와 같은 수준에서 또 다른 `then` 메서드를 연결하여 처리할 수 있습니다.
*   **브라우저 지원:** 현재 대부분의 브라우저가 Promise를 추가 코드 없이 지원하지만, 구형 브라우저 지원을 위해 폴리필(polyfill) 라이브러리를 추가할 수도 있습니다.

#### C. Async / Await
Async와 Await는 **ECMAScript 2017**의 일부로, Promise 작업을 훨씬 더 읽기 쉽게 만듭니다.

*   **`async` 키워드:** 함수에 `async` 키워드를 표시하여 해당 함수가 비동기적으로 작동함을 나타냅니다.
*   **`await` 키워드:** 네트워크 요청과 같은 Promise 기반 작업 앞에 `await` 키워드를 사용하여, 해당 결과가 반환될 때까지 코드 실행을 일시 중지하고, 반환 값을 콜백 함수 내부가 아닌 **변수에 직접 저장**할 수 있게 합니다.
*   **가독성 향상:** 이 방식은 많은 네트워크 요청을 수행하는 코드를 정말로 단축시키고 읽기 쉽게 만들 수 있습니다.
*   **지원:** `async`와 `await`는 상대적으로 새롭지만, 많은 브라우저와 현재 버전의 Node 모두 이를 지원합니다.

### 3. 비동기 코드와 현대 JavaScript 도구 (Tooling)

비동기 코드는 현대 JavaScript 개발 환경에서 도구들의 지원을 받으며 활용됩니다.

#### 트랜스파일러/컴파일러 (Transpilers/Compilers)
`async/await`와 같은 최신 JavaScript 기능들은 구형 브라우저에서 기본적으로 지원되지 않을 수 있습니다.

*   **Babel:** Babel과 같은 트랜스파일러는 **ES6 및 기타 최신 버전의 JavaScript**를 구형 브라우저에서 실행 가능한 **ECMAScript 5**로 변환하는 데 널리 사용됩니다.
*   **번들러 통합:** Babel과 같은 도구는 Webpack, Rollup 또는 Vite와 같은 모듈 번들러와 통합되어, 개발자가 최신 비동기 문법을 사용하더라도 최종적으로 빌드된 JavaScript는 광범위한 브라우저에서 호환되도록 만듭니다.

#### 패키지 관리자 (Package Managers)
비동기 작업을 위해 `Axios`나 `jQuery` 같은 외부 라이브러리를 사용하는 경우가 많으며, 이러한 라이브러리는 패키지 관리자를 통해 쉽게 통합됩니다.

*   **NPM 및 Yarn:** NPM(Node Package Manager) 및 Yarn은 필요한 JavaScript 라이브러리(예: Promise를 반환하는 네트워크 요청 라이브러리)를 설치하고, 해당 라이브러리의 모든 종속성을 표준 폴더 구조 내에 자동으로 관리합니다.

---
> 💡 **비유로 이해하기**
> 비동기 코드는 마치 효율적인 주방에서 케이크가 오븐에서 구워지는 동안(비동기 작업) 요리사가 가만히 기다리지 않고 프로스팅을 만드는 것처럼, 컴퓨터가 느린 작업의 완료를 기다리는 대신 다른 작업을 계속 진행할 수 있도록 하여 전체 시스템의 생산성과 응답성을 극대화하는 방법을 제시합니다.

---

## OOP (객체 지향 프로그래밍)

### 1. 객체 지향 JavaScript의 개념 및 모델

객체 지향 프로그래밍(OOP)은 코드 재사용성을 높이고 객체들이 상속 관계를 가지도록 데이터를 모델링하는 개념적인 접근 방식입니다. JavaScript의 객체는 본래 데이터를 묶는 일반적인 방법이지만, OOP 관점에서는 **데이터 타입에 대한 템플릿을 설정**하여 재사용 가능한 객체의 인스턴스(instance)를 생성하는 것을 목표로 합니다.

### A. 프로토타입 상속 (Prototypal Inheritance)

JavaScript가 객체 지향 개념을 구현하는 방식은 다른 인기 있는 언어들과 다릅니다.

1.  **모델:** JavaScript는 **프로토타입 상속(Prototypal Inheritance)**이라는 모델을 사용합니다.
2.  **프로토타입 체인:** 모든 객체는 부모 객체에 대한 링크를 가지며, 이 부모 객체로부터 데이터와 함수를 상속받습니다. 이 링크들은 내부적으로 `__proto__`라고 불리며, **프로토타입 체인(prototype chain)**을 구성합니다. 예를 들어, `ChocolateCake` 객체는 `Cake` 객체를 상속받고, `Cake` 객체는 다시 전역 `Object`를 상속받을 수 있습니다.
3.  **메서드 추가:** 객체의 프로토타입에 함수(`Bake`와 같은 메서드)를 추가함으로써, 해당 프로토타입을 사용하는 모든 객체가 그 함수를 상속받아 호출할 수 있게 됩니다.

### B. 클래스 키워드 (Class Keyword)

ECMAScript 6(ES6)에서는 **`class` 키워드**가 도입되었습니다.

*   **구문 설탕:** `class` 키워드를 사용하는 방식은 다른 프로그래밍 언어의 구문과 유사하여, 이전 객체 지향 경험이 있는 개발자들이 JavaScript에서 더 편안함을 느끼도록 돕습니다. 그러나 궁극적으로 이 `class` 구문은 여전히 내부적으로는 기존의 프로토타입 기반 선언으로 변환됩니다. 이처럼 언어의 작동 방식을 근본적으로 바꾸지 않고 구문만 개선하는 것을 **"구문 설탕(syntactic sugar)"**이라고 부릅니다.

### C. 데이터 모델링으로서의 객체

객체는 유사한 구조를 갖지만 내부 데이터가 다른 여러 객체를 생성하는 데 사용됩니다. 이러한 방식으로 데이터를 표현하는 것은 **객체 지향 프로그래밍 영역으로 진입**하기 시작하는 것을 의미합니다.

### 2. 고급 주제 및 도구와의 연관성

객체 지향 개념과 프로토타입 구조는 JavaScript 개발 환경의 여러 고급 측면 및 도구 사용에 영향을 미칩니다.

### A. 객체 및 배열의 참조(Reference) 관리

객체 지향의 근간인 객체(Object)와 배열(Array)은 함수에 인수로 전달될 때 **참조(reference)의 복사본**이 전달된다는 중요한 특징이 있습니다.

*   **참조에 의한 전달:** 함수 내에서 객체의 속성을 변경하면 **원본 객체가 수정**됩니다. 이는 배열에도 동일하게 적용됩니다.
*   **원본 보호:** 원본 데이터의 변형을 막고 함수에서 새로운 객체를 반환하려면, 함수 내에서 명시적으로 새로운 객체 복사본을 만들어야 합니다. 이는 OOP에서 객체의 상태를 안전하게 관리하는 데 중요한 고려 사항입니다.

### B. 스코프 (Scope) 및 `let`/`const`의 블록 스코프

JavaScript의 객체 지향적인 발전은 변수 스코프 관리 방식에도 영향을 미쳤습니다.

*   **`var` vs. `let`/`const`:** 전통적으로 `var`는 함수를 경계로 스코프가 결정되었지만, ECMAScript 2015부터 도입된 **`let`과 `const`** 키워드는 **블록 스코프(block scope)**를 생성합니다.
*   **OOP 프로젝트 구조:** 이러한 블록 스코프를 통해 개발자는 코드를 더 작은 블록으로 캡슐화할 수 있으며, 이는 **객체 지향 프로젝트에서 각 타입이나 클래스에 대한 파일**을 분리하고 관련 코드를 유지 관리하는 데 용이합니다.

### C. TypeScript를 통한 타입 안정성 강화

JavaScript의 유연성(loosely typed)은 버그를 유발할 수 있으며, 특히 대규모 객체 지향 프로젝트에서 문제가 될 수 있습니다.

*   **TypeScript:** **TypeScript**는 JavaScript에 **더 강력한 타입 검사(stronger typing)** 기능을 추가한 버전입니다.
*   **트랜스파일러/컴파일러:** 많은 대규모 JavaScript 프로젝트와 프레임워크는 원래 코드를 TypeScript로 작성한 후, **TypeScript 컴파일러**를 사용하여 웹에서 실행 가능한 **바닐라 JavaScript**로 변환(transpile)합니다. 이는 객체 지향 개념을 활용하는 대형 프로젝트의 안정성을 높이는 현대적인 도구의 활용 예시입니다.

### D. 모듈화 및 번들링 (Tooling)

현대 객체 지향 프로젝트에서는 코드를 관련성 있는 단위로 분할하여 관리하는 **모듈(modules)** 개념이 중요합니다.

*   **파일 분할:** 객체 지향 프로젝트에서 **각 타입 또는 클래스에 대한 파일**을 분리하는 것이 일반적입니다.
*   **번들러의 역할:** Webpack, Rollup, Vite와 같은 **번들러(bundlers)**는 이렇게 분할된 파일들의 종속성을 관리하고, 최종 JavaScript 코드를 최적화(예: 공백 제거)하여 웹에 효율적으로 배포될 수 있도록 돕습니다.
좋아. 이번에는 **{04_sw_architecture_design_pattern.md}**, 즉 _Software Architecture & Design Pattern_ 강의 내용을  
원문 순서 그대로 **생략 없이**, 이해하기 쉽게 **한국어로 정리한 노트**를 구성할게.  
이 파일은 실제 시스템 설계에서 매우 중요한 **소프트웨어 아키텍처(Architecture)** 와  
**디자인 패턴(Design Pattern)** 을 다루므로, 각 개념을 사례와 함께 풀어서 설명했어.

---

# 📘 Software Architecture & Design Pattern — 정리 노트

---

## 1️⃣ 소프트웨어 아키텍처 개요 (Introduction to Software Architecture)

### 🔹 소프트웨어 아키텍처란?

- 시스템의 **구조적 청사진(blueprint)** 이자,  
    소프트웨어 구성 요소들이 **어떻게 조직되고 상호작용하는지**를 정의하는 설계도이다.
    
- **SDLC의 설계 단계(Design Phase)** 에서 수행되며,  
    개발자들이 전체 구조를 이해하고 구현할 수 있도록 방향을 제시한다.
    

### 🔹 주요 역할

- 시스템 내의 **컴포넌트 간 관계, 동작 원리, 데이터 흐름, 기술 스택**을 정의.
    
- 시스템이 **성능, 보안, 유지보수성, 확장성, 이식성** 등의 요구를 충족하도록 지원한다.
    

### 🔹 아키텍처 설계의 중요성

1. **팀 간 의사소통 기반 제공** — 구조가 명확해야 협업이 쉬움.
    
2. **초기 설계 결정은 비용이 큼** — 한 번 구현되면 변경이 어렵기 때문.
    
3. **요구사항 변화 대응** — 유연한 구조는 변경에 강함.
    
4. **시스템 수명 연장** — 잘 설계된 구조는 기술 교체 후에도 재사용 가능.
    

### 🔹 기술 스택 결정에의 영향

- 아키텍처는 사용될 **프레임워크, 언어, DB, 클라우드 환경** 등의 선택에 직접 영향을 준다.
    
- 예: 고성능 분산 시스템 → Go, Kafka, Redis /  
    데이터 분석 플랫폼 → Python, Spark, PostgreSQL
    

### 🔹 설계 산출물 (Artifacts)

|산출물|설명|
|---|---|
|**SDD (Software Design Document)**|설계 세부사항과 기술 명세서|
|**Architectural Diagram**|주요 컴포넌트, 계층, 데이터 흐름 표현|
|**UML Diagram**|구조 및 동작을 언어 중립적으로 표현 (객체 간 관계, 상태, 상호작용 등)|

👉 SDD에는 가정, 제약, 요구사항, 설계 목표 등이 포함된다.  
👉 UML 다이어그램은 팀 간 커뮤니케이션에 핵심 도구로 사용됨.

---

## 2️⃣ 소프트웨어 설계와 모델링 (Software Design & Modeling)

### 🔹 소프트웨어 설계란?

- **시스템의 구조적(Structural)** 및 **행동적(Behavioral)** 속성을 코드 작성 전에 문서화하는 과정.
    
- 목표: 복잡한 문제를 작게 나누어 모듈화(Modularization)하고,  
    **시각적으로 표현**하여 개발자가 구조를 쉽게 이해하도록 돕는 것.
    

---

### ✳️ ① 구조적 설계 (Structured Design)

- 시스템을 여러 **모듈(Module)** 로 나누어 계층적으로 표현.
    
- **모듈 간 관계를 느슨하게(Loosely Coupled)**,  
    내부의 기능은 응집력 있게(Cohesive) 설계하는 것이 핵심 원칙이다.
    

|개념|의미|
|---|---|
|**Cohesion (응집도)**|하나의 모듈이 하나의 목적만 수행하도록 구성|
|**Coupling (결합도)**|모듈 간 의존성. 낮을수록 좋음|

**예시:**  
의료 청구 시스템  
→ 상위 모듈 “Billing”  
→ 하위 모듈: “Insurance Verification”, “Submit Claim”, “Output Total”  
→ 각 모듈은 서로 독립적이지만, 데이터 흐름으로 연결됨.

---

### ✳️ ② 행동 모델 (Behavioral Models)

- 시스템이 **무엇을 하는지**를 설명하지만, **어떻게 하는지**는 설명하지 않음.
    
- 대표적인 UML 모델:
    
    - **State Transition Diagram (상태 전이도)**
        
    - **Interaction Diagram (상호작용 다이어그램)**
        

---

### 🔹 UML (Unified Modeling Language)

- **언어 독립적**으로 시스템의 구조와 동작을 표현하는 **표준 모델링 언어**.
    
- 장점:
    
    1. 코드 작성 전에 시스템 구조를 미리 시각화 → 시간과 비용 절감
        
    2. 새 팀원이 빠르게 시스템을 이해
        
    3. 기술자와 비기술자 간 의사소통 가능
        
    4. 코드 내 관계를 한눈에 파악 가능
        

---

### 🔹 UML 다이어그램 예시

- **상태 전이 다이어그램 (State Transition Diagram)**  
    예: 병원 진료 프로세스
    
    ```
    [Waiting] → (call) → [With Doctor] → (done) → [Testing] → (complete) → [End]
    ```
    
- **상호작용 다이어그램 (Interaction / Sequence Diagram)**  
    예: 환자가 온라인으로 진료 예약
    
    - Patient → Portal → Doctor → Confirmation  
        → 시간 순서대로 객체 간 메시지 흐름 표시.
        

---

## 3️⃣ 객체지향 분석 및 설계 (Object-Oriented Analysis & Design, OOAD)

### 🔹 기본 개념

- **OOAD**는 객체지향 언어(Java, C++, Python 등)를 이용해  
    시스템을 **객체(Object)** 중심으로 분석·설계하는 접근법이다.
    

### 🔹 객체(Object)

- 데이터(속성, property)와 행동(메서드, method)을 하나로 묶은 단위.
    
- 예: `Patient` 객체 → 이름, 생년월일, 예약정보 등의 속성과  
    `makeAppointment()` 같은 행동을 가짐.
    

### 🔹 클래스(Class)

- 객체의 **청사진(template)** 역할.
    
- 실제 인스턴스(Object)는 이 클래스로부터 생성됨.
    

```python
class Patient:
    def __init__(self, name):
        self.name = name
```

### 🔹 상속(Inheritance)

- 하위 클래스(Subclass)는 상위 클래스의 속성과 메서드를 상속받음.
    
- 예:
    
    ```
    MedicalPersonnel
        ├── Doctor
        │    └── Specialist
        └── Nurse
    ```
    
    → Specialist는 Doctor의 모든 속성을 물려받음.
    

### 🔹 클래스 다이어그램(Class Diagram)

- 시스템의 정적 구조를 표현하는 UML의 한 종류.
    
- 각 클래스의 속성, 메서드, 관계(상속/의존/구성 등)를 표시.
    

---

## 4️⃣ 내부자 관점: 설계와 아키텍처의 중요성 (Insiders’ Viewpoint)

전문가들이 공통적으로 강조하는 핵심은 다음과 같다:

1. **"디자인이 없으면 방향이 없다"**  
    → 설계 없이 코드를 짜면 전체 구조가 혼란스러워진다.
    
2. **아키텍처는 오케스트라의 조율과 같다.**  
    → 모든 서비스가 서로 조화를 이루어야 한다.
    
3. **확장성(Scalability)과 지속 가능성(Sustainability)**  
    → 단기적 완성보다 장기적 유연성이 더 중요하다.
    
4. **데이터 흐름과 호출 관계를 먼저 정의하라.**  
    → API, 네트워크, 인증 구조 등은 초기에 결정해야 수정 비용이 적다.
    

---

## 5️⃣ 애플리케이션 아키텍처 접근법 (Approaches to Application Architecture)

### 🔹 컴포넌트(Component)

- 독립적이고 재사용 가능한 **기능 단위(Unit of Functionality)**.
    
- **6가지 특성:**
    
    1. Reusable (재사용 가능)
        
    2. Replaceable (교체 가능)
        
    3. Independent (독립적)
        
    4. Extensible (확장 가능)
        
    5. Encapsulated (캡슐화)
        
    6. Non-context-specific (환경 독립적)
        

### 🔹 컴포넌트 예시

- **API 컴포넌트:** 여러 시스템에서 공용 사용
    
- **DAO (Data Access Object):** DB 인터페이스 추상화
    
- **Controller:** 이벤트 발생 시 데이터 흐름 제어
    

### 🔹 서비스(Service)와 SOA

- 서비스(Service)는 하나의 독립적인 기능 단위로, 여러 시스템에서 재사용 가능.
    
- **SOA (Service-Oriented Architecture):**
    
    - 서비스들이 네트워크를 통해 통신하며 협업하는 구조.
        
    - 예: “신용조회”, “대출 계산”, “계약 승인” 서비스 등이 독립적으로 존재.
        
- 서비스는 일반적으로 **항상 켜져 있는 단일 인스턴스**로 동작함.
    

### 🔹 분산 시스템 (Distributed System)

- 여러 서비스가 **다른 서버나 노드**에 분산되어 실행되는 구조.
    
- 사용자 입장에서는 하나의 통합 시스템처럼 보임.
    

**특징:**

1. 병렬 처리(Throughput↑)
    
2. 장애 허용(Fault Tolerant)
    
3. 확장성(Scalable)
    
4. 이기종 환경 지원(다른 OS, 언어 혼합 가능)
    

**대표 구조:**  
Client-Server / 3-Tier / Peer-to-Peer / Microservices

---

## 6️⃣ 아키텍처 패턴 (Architectural Patterns)

### 주요 5가지 유형:

|패턴|설명|예시|
|---|---|---|
|**2-Tier (Client-Server)**|클라이언트 ↔ 서버 구조|메시징 앱, DB 클라이언트|
|**3-Tier (Presentation–Logic–Data)**|UI / Business Logic / Database 3계층 분리|대부분의 웹 애플리케이션|
|**Peer-to-Peer (P2P)**|중앙 서버 없이 노드 간 자원 공유|BitTorrent, Blockchain|
|**Event-Driven**|이벤트 생산자–소비자 구조, 비동기 메시징 기반|Uber, Lyft 등 Ride-sharing 앱|
|**Microservices**|여러 독립 서비스가 API로 연결된 구조|Facebook, Netflix, Amazon|

### 🔹 혼합 구조도 가능

- 3-Tier + Microservices (웹 기반 대규모 시스템)
    
- Event-Driven + P2P (실시간 분산 시스템)
    
- 단, **P2P와 2-Tier는 병행 불가** (역할 구조 상 충돌)
    

---

## 7️⃣ 배포 환경 (Application Deployment Environments)

|환경|설명|
|---|---|
|**Development (개발)**|개발자 로컬 또는 개발 서버에서 코딩 진행|
|**QA / Testing**|품질보증팀이 기능 테스트 수행|
|**Staging**|실제 배포 전, Production 환경과 동일하게 시뮬레이션|
|**Production**|사용자에게 제공되는 실제 운영 환경|

### 🔹 배포 방식

1. **On-Premises (온프레미스):**  
    기업 내부 서버에 직접 설치 (보안 강함, 비용 높음)
    
2. **Cloud (클라우드):**
    
    - **Public Cloud:** AWS, Azure, GCP (확장성 높음)
        
    - **Private Cloud:** 단일 기업 전용 (보안 우수)
        
    - **Hybrid Cloud:** 공공 + 사설 혼합 (비용/보안 균형)
        

---

## 8️⃣ 프로덕션 배포 구성 요소 (Production Deployment Components)

|구성요소|역할|
|---|---|
|**Firewall (방화벽)**|네트워크 접근 통제, 악성 접근 차단|
|**Load Balancer**|여러 서버로 트래픽 분산|
|**Web Server**|정적 콘텐츠(HTML, CSS, 이미지) 제공|
|**Application Server**|비즈니스 로직 처리|
|**Proxy Server**|요청 중계, 캐싱, 보안, 로드밸런싱 지원|
|**Database Server**|데이터 저장 및 질의 처리 (DBMS 포함)|

### 구조 예시 (N-Tier):

```
Client
   ↓
Firewall
   ↓
Web Load Balancer → Web Servers
   ↓
App Load Balancer → App Servers
   ↓
Database Server (Primary + Replica)
```

---

## 🧠 전체 요약

|주제|핵심 포인트|
|---|---|
|**소프트웨어 아키텍처**|시스템 구조와 컴포넌트 관계 정의|
|**UML 및 설계**|구조적·행동적 모델로 시스템 표현|
|**OOAD**|객체지향 분석·설계로 확장성 확보|
|**컴포넌트 & 서비스**|독립적 재사용 단위, SOA 기반 통신|
|**분산 시스템**|여러 서버에서 병렬 작동하는 유연한 구조|
|**아키텍처 패턴**|2-Tier, 3-Tier, P2P, Event-Driven, Microservices|
|**배포 환경 & 구성요소**|Dev → QA → Staging → Production 순서로 구축|

---

이 노트는 `{04_sw_architecture_design_pattern.md}`의 전체 내용을  
**원문 순서 그대로** 정리한 완전 해설본이야.  
원하면 다음 파일인 `{05_job_skillset.md}` 도 같은 방식으로 이어서 정리해줄까?